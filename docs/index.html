<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>amps API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>amps</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import traceback
import os
import json
import uuid


class Util:
    &#34;&#34;&#34;The `Util` class provides utility methods that may be useful during action and service execution.


    &#34;&#34;&#34;
    def get_id():
        &#34;&#34;&#34;Utility method that returns a unique ID in the format used by AMPS.
        &#34;&#34;&#34;
        return uuid.UUID(str(uuid.uuid4())).hex

    @staticmethod
    def unravel_erlport_object(result):
        if isinstance(result, List):
            return [Util.unravel_erlport_object(x) for x in result]
        elif isinstance(result, Map):
            return {k.decode(): Util.unravel_erlport_object(v) for k, v in result.items()}
        elif isinstance(result, Atom):
            return result.decode()
        elif isinstance(result, bytes):
            return result.decode()
        else:
            return result


class Logger:
    &#34;&#34;&#34;The `Logger` class from AMPS is a utility class for logging events back to AMPS. This class should not be used directly, but rather instances of this class within Actions, Endpoints, and Services should be used.

    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            self.logger.info(&#34;Action Execution Started&#34;)
            # Perform Action Logic Here
    ```
    &#34;&#34;&#34;

    def __init__(self, sid=&#34;&#34;, service=None):
        self.__sid__ = sid
        self.__service__ = service

    def log(self, level: str, message: str):
        &#34;&#34;&#34;Instance method that logs a given message with the given level.

        Args:
            level (string): The level to use when logging the given message. All valid &#34;level&#34; values are available in the docs for the [Logger](https://hexdocs.pm/logger/1.13/Logger.html#module-levels) Elixir library underlying this class.
            message (string): The message to log.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                self.logger.log(&#34;info&#34;, &#34;Action Execution Started&#34;)
                # Perform Action Logic Here
        ```
        &#34;&#34;&#34;
        if self.__service__:
            self.__service__.__log__(Atom(
                bytes(level, &#34;utf-8&#34;)), message)
        else:
            call(Atom(b&#39;Elixir.Amps.PyHandler&#39;), Atom(b&#39;log&#39;), [Atom(
                bytes(level, &#34;utf-8&#34;)), message, [(Atom(b&#39;sid&#39;), self.__sid__)]])

    def info(self, message: str):
        &#34;&#34;&#34;Instance method that logs a given message with the &#34;info&#34; level.

        Args:
            message (string): The message to log.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                self.logger.info(&#34;Action Execution Started&#34;)
                # Perform Action Logic Here
        ```
        &#34;&#34;&#34;
        self.log(&#34;info&#34;, message)

    def debug(self, message: str):
        &#34;&#34;&#34;Instance method that logs a given message with the &#34;debug&#34; level.

        Args:
            message (string): The message to log.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                self.logger.debug(&#34;Received message&#34;)
        ```
        &#34;&#34;&#34;
        self.log(&#34;debug&#34;, message)

    def warning(self, message: str):
        &#34;&#34;&#34;Instance method that logs a given message with the &#34;warning&#34; level.

        Args:
            message (string): The message to log.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                self.logger.warning(&#34;Something minor went wrong.&#34;)
        ```
        &#34;&#34;&#34;
        self.log(&#34;warning&#34;, message)

    def error(self, message: str):
        &#34;&#34;&#34;Instance method that logs a given message with the &#34;error&#34; level.

        Args:
            message (string): The message to log.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                self.logger.error(&#34;Something major went wrong.&#34;)
        ```
        &#34;&#34;&#34;
        self.log(&#34;error&#34;, message)


class DB:
    def __init__(self, env):
        self.env = env

    def find(self, collection, clauses={}, opts={}):
        coll = bytes(collection, &#34;utf-8&#34;)
        collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
            b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
        clauses = Map(clauses)
        opts = Map(opts)
        result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                      Atom(b&#39;find&#39;), [collection, clauses, opts])
        return Util.unravel_erlport_object(result)

    def find_one(self, collection, clauses={}, opts={}):
        coll = bytes(collection, &#34;utf-8&#34;)
        collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
            b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
        clauses = Map(clauses)
        opts = Map(opts)
        result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                      Atom(b&#39;find_one&#39;), [collection, clauses, opts])
        return Util.unravel_erlport_object(result)

    def create(self, collection, body):
        coll = bytes(collection, &#34;utf-8&#34;)
        collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
            b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
        body = Map(body)
        result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                      Atom(b&#39;create&#39;), [collection, body])
        return Util.unravel_erlport_object(result)

    def update(self, collection, body, id):
        coll = bytes(collection, &#34;utf-8&#34;)
        id = bytes(id, &#34;utf-8&#34;)
        collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
            b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
        body = Map(body)
        result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                      Atom(b&#39;update&#39;), [collection, body, id])
        return Util.unravel_erlport_object(result)

    def delete(self, collection, id):
        coll = bytes(collection, &#34;utf-8&#34;)
        id = bytes(id, &#34;utf-8&#34;)
        collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
            b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
        result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                      Atom(b&#39;delete&#39;), [collection, id])
        return Util.unravel_erlport_object(result)


class Users:
    def __init__(self, env):
        self.env = env

    def find(self, env, clauses={}, opts={}):
        coll = bytes(collection, &#34;utf-8&#34;)
        collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
            b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
        clauses = Map(clauses)
        opts = Map(opts)
        result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                      Atom(b&#39;find&#39;), [collection, clauses, opts])
        return Util.unravel_erlport_object(result)

    def find_one(self, env, clauses={}, opts={}):
        coll = bytes(collection, &#34;utf-8&#34;)
        collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
            b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
        clauses = Map(clauses)
        opts = Map(opts)
        result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                      Atom(b&#39;find_one&#39;), [collection, clauses, opts])
        return Util.unravel_erlport_object(result)

    def create(self, user):
        user = Map(user)
        result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                      Atom(b&#39;create&#39;), [user, self.env])
        return Util.unravel_erlport_object(result)

    def update(self, id, body):
        user = Map(body)
        result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                      Atom(b&#39;update&#39;), [id, user, self.env])
        return Util.unravel_erlport_object(result)

    def delete(self, id):
        result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                      Atom(b&#39;delete&#39;), [id, self.env])
        return Util.unravel_erlport_object(result)

    def create_session(self, user):
        user = Map(user)
        result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                      Atom(b&#39;create_session&#39;), [user, self.env])
        return Util.unravel_erlport_object(result)

    def authenticate(self, access_token):
        result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                      Atom(b&#39;authenticate&#39;), [access_token, self.env])
        return Util.unravel_erlport_object(result)

    def renew_session(self, renewal_token):
        result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                      Atom(b&#39;renew_session&#39;), [renewal_token, self.env])
        return Util.unravel_erlport_object(result)

    def delete_session(self, access_token):
        result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                      Atom(b&#39;delete_session&#39;), [access_token, self.env])
        return Util.unravel_erlport_object(result)


class Action:
    &#34;&#34;&#34;The `Action` class from AMPS provides a base class for actions that must be extended in a custom action. Actions can be performed by overriding the `Action.action` callback exposed by the class.

    Attributes:
        msg (dict): The msg attribute contains a python of the dictionary and the message with all of its metadata. Message data can be accessed from the msg attribute, either using the &#34;data&#34; key for inline data, or the &#34;fpath&#34; key for a path to the file containing the data.
        parms (dict): The parms attribute contains all the parameters of the configured action including any extra parameters you may have specified under the &#34;parms&#34; key.
        sysparms (dict): The sysparms attribute contains all useful system configuration parameters for use in actions. Currently, sysparms only contains the AMPS temporary directory under the &#34;tempdir&#34; key.
        extra (dict): The extra attribute contains all extra parameters configured in the action.
        provider (dict): If use_provider is true on the configured action, the provider attribute contains the provider parameters. The provider parameters are available under the parms  object as well under the &#34;provider&#34; key.
        logger (Logger): The logger attribute exposes a Logger object for logging events back to AMPS. Any messages logged using this object during the action execution will appear in the corresponding session logs.

    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            # Get Message Data (This example assumes inline).
            data = self.msg[&#34;data&#34;]
            # Perform Action Logic Here
            if success:
                self.logger.info(&#34;Successfully Processed Message&#34;)
                return Action.send_status(&#34;completed&#34;)
            else:
                self.logger.warn(&#34;Failed to process message&#34;)
                return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
    ```
    &#34;&#34;&#34;

    def __init__(self, msgdata):
        msgdata = json.loads(msgdata)
        self.msg = msgdata[&#34;msg&#34;]
        self.parms = msgdata[&#34;parms&#34;]
        self.sysparms = msgdata[&#34;sysparms&#34;]
        self.extra = self.parms[&#34;parms&#34;]
        self.env = self.parms[&#34;env&#34;]
        self.db = DB(self.env)
        self.users = Users(self.env)

        if self.parms[&#34;use_provider&#34;]:
            self.provider = self.parms[&#34;provider&#34;]
        if self.msg.get(&#34;sid&#34;):
            self.logger = Logger(sid=self.msg[&#34;sid&#34;])
        else:
            self.logger = Logger()

    def __run__(self):
        try:
            response = self.action()
        except Exception as e:
            response = {&#34;error&#34;: True, &#34;reason&#34;: str(e)}
        return json.dumps(response)

    def action(self):
        &#34;&#34;&#34;Callback to override in order to perform action logic in a class that extends `Action`.

        Relevant message data is available via the attributes available on the self object. It expects the method to return a python dictionary with at least a &#34;status&#34; key with the status of the action execution. If the action execution is unsuccessful, a &#34;reason&#34; key can also be returned along with an unsuccessful status. If a new message is intended to be created by this action, it is also expected that a &#34;msg&#34; key will be returned with a dictionary object containing either a &#34;data&#34; key with inline data or an &#34;fpath&#34; key containing the file path to the message. Similarly, actions used in Endpoints can return a &#34;response&#34; object with the response status code specified under the &#34;code&#34; key, and the response body provided via either the &#34;data&#34; or &#34;fpath&#34; key. The action method is automatically wrapped in a try-except block when it is called, so is unnecessary to wrap the overall method in a try-except block. If you wish to have more granular visibility over errors that arise in your actions, feel free to use try-except blocks at various steps throughout action execution to allow for logging specific reasons for failure. To simplify action creation and handling, a number of helper methods are exposed by the class as static methods.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                if success:
                    return Action.send_status(&#34;completed&#34;)
                else:
                    return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
        ```
        &#34;&#34;&#34;
        return {&#34;status&#34;: &#34;completed&#34;}

    def get_data(self):
        &#34;&#34;&#34;Convenience method to read get string data from message.

        Returns either the inline message data stored on the &#34;data&#34; key or the data stored in the message&#39;s file via the &#34;fpath&#34; key.
        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                data = self.get_data()
                # Use data here
                if success:
                    return Action.send_status(&#34;completed&#34;)
                else:
                    return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
        ```
        &#34;&#34;&#34;
        if self.msg.get(&#34;data&#34;):
            return self.msg[&#34;data&#34;]
        else:
            return open(self.msg[&#34;fpath&#34;]).read()

    @staticmethod
    def send_async(status, key, data):
        &#34;&#34;&#34;Static method for creating a dictionary with the provided status and an async key with the provided data for asynchronously returning from an API endpoint.

        Args:
            status (string): The Action status to log.
            key (string): The key to use for this data when returning the json object.
            data (string || dict): Either a string containing the response data or a dictionary which will be JSON encoded and return.

        This convenience method allows for returning data asynchronously from a script when used in an API Endpoint-triggered topic workflow.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                if success:
                    return Action.send_async(&#34;completed&#34;, &#34;Hello, this is my async response.&#34;)
                else:
                    return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
        ```
        &#34;&#34;&#34;
        return {&#34;status&#34;: status, &#34;async&#34;: {key: data}}

    @staticmethod
    def send_status(status: str, reason: str = None):
        &#34;&#34;&#34;Static method for creating a dictionary with the provided status and optional reason for returning in the `action` callback.

        Args:
            status (string): The Action status to log.
            reason (string): An optional reason to provide along with the given status.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                if success:
                    return Action.send_status(&#34;completed&#34;)
                else:
                    return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
        ```
        &#34;&#34;&#34;
        if reason:
            return {&#34;status&#34;: status, &#34;reason&#34;: reason}
        else:
            return {&#34;status&#34;: status}

    @staticmethod
    def send_file(status: str, fpath: str, meta: dict = {}):
        &#34;&#34;&#34;Static method for creating a dictionary with the provided status and a new message from the provided fpath and additional metadata for returning in the `Action.action` callback.

        Args:
            status (string): The Action status to log.
            fpath (string): A filepath to a file containing the message data.
            meta (dict): An optional dictionary containing additional metadata to add to the new message.

        This convenience method allows for the creation of a new message using the file specified in `fpath` and any additional metadata supplied in `meta`. File Size (fsize) and File Name (fname) are automatically retrieved from the given file.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                if success:
                    return Action.send_file(&#34;completed&#34;, &#34;path/to/file&#34;, {&#34;partner&#34;: &#34;companyX&#34;})
                else:
                    return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
        ```
        &#34;&#34;&#34;
        fname = os.path.basename(fpath)
        fsize = os.path.getsize(fpath)
        msg = {**{&#34;fname&#34;: fname, &#34;fsize&#34;: fsize, &#34;fpath&#34;: fpath}, **meta}
        return {&#34;status&#34;: status, &#34;msg&#34;: msg}

    @staticmethod
    def send_data(status: str, data: str, meta: dict = {}):
        &#34;&#34;&#34;Static method for creating a dictionary with the provided status and a new message with the provided inline data and additional metadata for returning in the `action` callback.

        Args:
            status (string): The Action status to log.
            fpath (string): A string containing the message data.
            meta (dict): An optional dictionary containing additional metadata to add to the new message.

        This convenience method allows for the creation of a new message using the inline data specified in `data` and any additional metadata supplied in `meta`.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                if success:
                    return Action.send_data(&#34;completed&#34;, &#34;Hello, this is my inline data.&#34;, {&#34;partner&#34;: &#34;companyX&#34;})
                else:
                    return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
        ```
        &#34;&#34;&#34;
        msg = {**{&#34;data&#34;: data}, **meta}
        return {&#34;status&#34;: status, &#34;msg&#34;: msg}

    @staticmethod
    def send_error(reason: str):
        &#34;&#34;&#34;Static method for handling errors by creating a dictionary with a ``failed`` status and the provided reason for returning in the `Action.action` callback.

        Args:
            reason (string): The reason for the action failure.

        This convenience method allows for the quick handling of error using the default ``failed`` status along with the reason specified in :param`reason`.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                if success:
                    return Action.send_status(&#34;completed&#34;)
                else:
                    return Action.send_error(&#34;Reason for Failure&#34;)
        ```
        &#34;&#34;&#34;
        return {&#34;status&#34;: &#34;failed&#34;, &#34;reason&#34;: reason}


class Endpoint(Action):
    &#34;&#34;&#34;The `Endpoint` class from AMPS extends the `Action` class to provide additional convenience in setting up API endpoint actions. Like regular actions, endpoint actions can be performed by overriding the `Action.action` callback exposed by the class.

    Attributes:
        msg (dict): The msg attribute contains a python of the dictionary and the message with all of its metadata. Message data can be accessed from the msg attribute, either using the &#34;data&#34; key for inline data, or the &#34;fpath&#34; key for a path to the file containing the data.
        parms (dict): The parms attribute contains all the parameters of the configured action including any extra parameters you may have specified under the &#34;parms&#34; key.
        sysparms (dict): The sysparms attribute contains all useful system configuration parameters for use in actions. Currently, sysparms only contains the AMPS temporary directory under the &#34;tempdir&#34; key.
        provider (dict): If use_provider is true on the configured action, the provider attribute contains the provider parameters. The provider parameters are available under the parms  object as well under the &#34;provider&#34; key.
        logger (Logger): The logger attribute exposes a Logger object for logging events back to AMPS. Any messages logged using this object during the action execution will appear in the corresponding session logs.
        path_params (dict): The path_params attribute contains any parameters that were passed to the endpoint via the URL. It is also available on the `msg` attribute via the &#34;path_params&#34; key.
        query_params (dict): The query_params attribute contains any parameters that were passed to the endpoint via the query parameters. It is also available on the `msg` attribute via the &#34;query_params&#34; key.

    Unlike actions, which are typically performed asynchronous via topic workflows, because Endpoints are called synchronously, if the endpoint action executes successfully, but produces an erroneous state, the action should return a successful status with the appropriate error code and response body under the &#34;response&#34; key.

    Usage:
    ```
    from amps import Endpoint
    class my_endpoint(Endpoint):
        def action(self):
            # Perform Endpoint Logic Here
            if success:
                return Endpoint.send_resp_file(&#34;path/to/file&#34;, 200)
            else:
                return Endpoint.send_resp_data(&#34;File not found.&#34;, 404)
    ```
    &#34;&#34;&#34;

    def __init__(self, msgdata):
        super().__init__(msgdata)
        self.path_params = self.msg.get(&#34;path_params&#34;)
        self.query_params = self.msg.get(&#34;query_params&#34;)

    def send_resp_data(data: str, code: int):
        &#34;&#34;&#34;Static method for creating a dictionary with the provided inline data and status code in the &#34;response&#34; object for returning in the `Action.action` callback.

        Args:
            data (string): The inline data to supply in the response body.
            code (integer): An integer containing the response status code to set.

        Usage:
        ```
        from amps import Endpoint
        import json
        class my_endpoint(Endpoint):
            def action(self):
                # Perform Endpoint Logic Here
                if success:
                    return Endpoint.send_resp_data(json.dumps({&#34;id&#34;: 1, &#34;name&#34;: &#34;Test User&#34;}), 200)
                else:
                    return Endpoint.send_resp_data(&#34;User not found.&#34;, 404)
        ```
        &#34;&#34;&#34;
        return {&#34;status&#34;: &#34;completed&#34;, &#34;response&#34;: {&#34;data&#34;: data, &#34;code&#34;: code}}

    def send_resp_file(fpath, code):
        &#34;&#34;&#34;Static method for creating a dictionary with the provided file path and status code in the &#34;response&#34; object for returning in the `Action.action` callback.

        Args:
            fpath (string): The path to file to send in the response body.
            code (integer): An integer containing the response status code to set.

        This convenience method allows for the convenient sending of a file in the response of a request along with the specified status code.

        Usage:
        ```
        from amps import Endpoint
        class my_endpoint(Endpoint):
            def action(self):
                # Perform Endpoint Logic Here
                if success:
                    return Endpoint.send_resp_file(&#34;path/to/file&#34;, 200)
                else:
                    return Endpoint.send_resp_data(&#34;File not found.&#34;, 404)
        ```
        &#34;&#34;&#34;
        return {&#34;status&#34;: &#34;completed&#34;, &#34;response&#34;: {&#34;fpath&#34;: fpath, &#34;code&#34;: code}}


responses = {}


class Service:
    &#34;&#34;&#34;The `Service` class from AMPS provides a base class for custom python services that can be managed by AMPS, and act as both consumers of messages and producers of new messages.

    Attributes:
        parms (dict): The parms attribute contains all the parameters of the configured service.
        sysparms (dict): The sysparms attribute contains all useful system configuration parameters for use in services. Currently, sysparms only contains the AMPS temporary directory under the &#34;tempdir&#34; key.
        config (dict): The config attribute contains all the custom configuration provided when creating the service. All config is also available in the parms attribute under the &#34;config&#34; key.
        logger (Logger): The logger attribute exposes a Logger object for logging events back to AMPS. Any messages logged using this object during the message handling or creation will appear in the corresponding session logs.
        env (string): The name of the AMPS environment in which this service is running.

    The `Service` class provides even more flexibility than the `Action` class in extending the functionality of AMPS. Unlike actions which are run and stopped, services can manage processes such as consumers/subscribers, web servers and sockets, etc, allowing the service to consume messages from and produce messages to AMPS.

    The class exposes two callback methods, `Service.initialize` and `Service.handle_message`.
    - `initialize` can be used to perform any initialization actions and start any subprocesses. Note that any subprocesses should be started in a separate thread in order to not block the main thread.
    - `handle_message` can be used to receive messages from the topic specified in the service configuration.

    The class additionally contains two methods for creating messages, `Service.send_message` and `Service.send_new`.
    `Service.send_message` should generally be used in handle_message in order to indicate that the message being created is stemming from the received message.
    Conversely, `Service.send_new` should be used to create new messages originating from an external source, such as a web server or consumer.

    Usage:
    ```
    from amps import Service
    class my_service(Service):
        def initialize(self):
            # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
            # Perform any other startup logic.

        def handle_message(self, msg, logger):
            # Maybe deliver this message to my subprocess or use it to process/transform the message.
            # Send a new message stemming from this message.
            self.send_message(
                msg, {&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;})


    ```
    &#34;&#34;&#34;

    def __init__(self, parms, sysparms, pid, env, lhandler):
        self.parms = json.loads(parms)
        self.sysparms = json.loads(sysparms)
        self.config = self.parms[&#34;config&#34;]
        self.env = env
        self.logger = Logger(service=self)
        self.__pid__ = pid
        self.__lhandler__ = lhandler
        self.initialize()

    def __receive__(self, data):
        try:
            msg = json.loads(data)
            logger = Logger(sid=msg[&#34;sid&#34;])

            logger.info(
                f&#39;Message received by Custom Service {self.parms[&#34;name&#34;]}&#39;)
            resp = self.handle_message(msg, logger)
            return (Atom(b&#39;ok&#39;), resp)
        except Exception as e:
            return (Atom(b&#39;error&#39;), str(e))

    def __response__(self, resp, id):
        global responses
        responses[id.encode(&#34;ascii&#34;)] = resp
        # f = open(id, &#34;w&#34;).write(resp)

    def __await_response__(self, id):
        global responses
        resp = responses.get(id)
        while not resp:
            resp = responses.get(id)
        return responses.pop(id)

    def __send__(self, msg):
        cast(self.__pid__, msg)

    def __send_and_receive__(self, msg):
        id = Util.get_id().encode(&#34;ascii&#34;)
        global responses
        cast(self.__pid__, (msg, id))
        resp = self.__await_response__(id)
        return json.loads(resp)

    def __log__(self, level, msg):
        cast(self.__lhandler__, (Atom(b&#39;log&#39;), (level, msg)))

    def initialize(self):
        &#34;&#34;&#34;Instance method for performing any initialization logic and starting any subprocesses.  
        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def initialize(self):
                # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
                # Perform any other startup logic.
        ```
        &#34;&#34;&#34;
        pass

    def send_message(self, msg: dict, newmsg: dict):
        &#34;&#34;&#34;Instance method for sending messages transformed by the `handle_message` callback. 
        The method accepts the original message which should be provided as is, as well as the new message with any new metadata to merge with the original message. If a &#34;data&#34; or &#34;fpath&#34; value is provided, it will overwrite the inline &#34;data&#34; or &#34;fpath&#34; on the current message. New message IDs are automatically generated and added by and retuned from this method for convenience.



        Args:
            msg (dict): The original message currently being processed in `handle_message`.
            newmsg (dict): A dictionary containing any new metadata to overwrite in the outgoing message.
        Returns:
            msgid: Message ID of the newly sent message.


        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def initialize(self):
                # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
                # Perform any other startup logic.

            def handle_message(self, msg, logger):
                # Maybe deliver this message to my subprocess or use it to process/transform the message.
                # Send a new message stemming from this message.
                self.send_message(msg, {&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;})
        ```
        &#34;&#34;&#34;
        msgid = Util.get_id()
        newmsg[&#39;parent&#39;] = msg[&#39;msgid&#39;]
        newmsg[&#39;msgid&#39;] = msgid
        if &#34;data&#34; in newmsg:
            del msg[&#34;fpath&#34;]
            newmsg[&#34;fsize&#34;] = len(newmsg[&#34;data&#34;])
        elif &#34;fpath&#34; in newmsg:
            del msg[&#34;data&#34;]
            newmsg[&#34;fsize&#34;] = os.path.getsize(newmsg[&#34;fpath&#34;])
        call(Atom(b&#39;Elixir.Amps.PyHandler&#39;), Atom(b&#39;send_message&#39;),
             [json.dumps({**msg, **newmsg}), json.dumps(self.parms), self.env])
        return msgid

    def send_new(self, newmsg: dict, action: str, response=False, timeout=15000):
        &#34;&#34;&#34;Instance method for sending new messages generated from an external source. 

        Args:
            newmsg (dict): A dictionary containing the new outgoing message to send. 
            action (str): The output map action to use when sending this message.
            response (boolean): Whether to wait for and receive all the outputs or results of the processing of new message.
            timeout (int): When response is True, this indicates how long to wait for a response from message processing. 

        Returns:
            response: If response is True, will return result of message processing, otherwise will return message ID of the newly sent message.

        The method accepts a new message with any additional metadata. If a &#34;data&#34; of &#34;fpath&#34; is provided, associated metadata is also generated. In order to get a result from the topic-based message processing of the new message, the response parameter can be passed as True.

        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def initialize(self):
                # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
                # Perform any other startup logic.

            def my_custom_function(self):
                # Any additional method in which are you generating a new message using an external source.
                self.send_new({&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;}, &#34;myaction_name&#34;)
        ```
        &#34;&#34;&#34;
        msgid = Util.get_id()
        newmsg[&#39;msgid&#39;] = msgid
        if &#34;data&#34; in newmsg:
            newmsg[&#34;fsize&#34;] = len(newmsg[&#34;data&#34;])
        else:
            newmsg[&#34;fsize&#34;] = os.path.getsize(newmsg[&#34;fpath&#34;])
        resp = self.__send_and_receive__((Atom(
            b&#39;new&#39;), json.dumps(newmsg), action, response, timeout))
        return resp

    def create_session(self, user={}):
        &#34;&#34;&#34;Instance method for authenticating and creating a session for an AMPS user.  

        Args:
            user (dict): A dictionary with a username and password key to use for authentication.

        Returns:
            success: A boolean indicating whether the operation was succesful.
            response: Either an error message when the operation fails or a dictionary with the following keys:
                access_token (str): The access token to use to authenticate the user.
                renewal_token (str): The renewal token when renewing the user&#39;s session. 
                user (dict): A dictionary containing all the user details. 
        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def my_custom_login(self, user):
                response = self.create_session(user)
                if response[&#34;success&#34;]:
                    # Handle Success
                else:
                    # Handle Failure

        ```
        &#34;&#34;&#34;
        resp = self.__send_and_receive__((Atom(
            b&#39;authenticate&#39;), json.dumps(user)))
        return resp

    def renew_session(self, renewal_token: str):
        &#34;&#34;&#34;Instance method for renewing an AMPS user&#39;s session.

        Args:
            renewal_token (str): A string containing the renewal token received when creating or renewing the session.

        Returns:
            success: A boolean indicating whether the operation was succesful.
            response: Either an error message when the operation fails or a dictionary with the following keys:
                access_token (str): The access token to use to authenticate the user.
                renewal_token (str): The renewal token when renewing the user&#39;s session. 
                user (dict): A dictionary containing all the user details. 
        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def my_renewal(self, renewal_token):
                response = self.renew_session(renewal_token)
                if response[&#34;success&#34;]:
                    # Handle Success
                else:
                    # Handle Failure

        ```
        &#34;&#34;&#34;
        resp = self.__send_and_receive__((Atom(
            b&#39;renew&#39;), renewal_token))
        return resp

    def verify(self, access_token: str):
        &#34;&#34;&#34;Instance method for verifying an AMPS user&#39;s session. 

        Args:
            access_token (str): A string containing the current access token for the user&#39;s session

        Returns:
            user: Either a dictionary with the user data on successful verification or False for failed verification. 
        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def post(self, *args):
                access_token = self.request.headers.get(&#39;Authorization&#39;)
                verified = self.verify(access_token)
                if verified:
                    # Perform Logic Here
                else:
                    # Send Error
                    self.send_error(401)

        ```
        &#34;&#34;&#34;
        resp = self.__send_and_receive__((Atom(
            b&#39;fetch&#39;), access_token))
        return resp

    def delete_session(self, access_token: str):
        &#34;&#34;&#34;Instance method for deleting an AMPS user&#39;s session. 

        Args:
            access_token (str): A string containing the current access token for the user&#39;s session

        Returns:
            success: A boolean indicating whether the operation was succesful.

        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def delete(self, *args):
                access_token = self.request.headers.get(&#39;Authorization&#39;)
                resp = self.delete_session(access_token)

        ```
        &#34;&#34;&#34;
        resp = self.__send_and_receive__((Atom(
            b&#39;delete&#39;), access_token))
        return resp

    def handle_message(self, msg: dict, logger: Logger):
        &#34;&#34;&#34;Callback method for receiving messages on the configured topic. 

        Args:
            msg (dict): The msg args contains a python dictionary of the message with all of its metadata. Message data can be accessed from the msg attribute, either using the &#34;data&#34; key for inline data, or the &#34;fpath&#34; key for a path to the file containing the data. 
            logger (Logger): A logger corresponding to the currently received message. Logging event using this object will accordingly render them in the corresponding message event sessions.
        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def initialize(self):
                # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
                # Perform any other startup logic.
        ```
        &#34;&#34;&#34;
        return &#34;completed&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="amps.Action"><code class="flex name class">
<span>class <span class="ident">Action</span></span>
<span>(</span><span>msgdata)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="amps.Action" href="#amps.Action">Action</a></code> class from AMPS provides a base class for actions that must be extended in a custom action. Actions can be performed by overriding the <code><a title="amps.Action.action" href="#amps.Action.action">Action.action()</a></code> callback exposed by the class.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>msg</code></strong> :&ensp;<code>dict</code></dt>
<dd>The msg attribute contains a python of the dictionary and the message with all of its metadata. Message data can be accessed from the msg attribute, either using the "data" key for inline data, or the "fpath" key for a path to the file containing the data.</dd>
<dt><strong><code>parms</code></strong> :&ensp;<code>dict</code></dt>
<dd>The parms attribute contains all the parameters of the configured action including any extra parameters you may have specified under the "parms" key.</dd>
<dt><strong><code>sysparms</code></strong> :&ensp;<code>dict</code></dt>
<dd>The sysparms attribute contains all useful system configuration parameters for use in actions. Currently, sysparms only contains the AMPS temporary directory under the "tempdir" key.</dd>
<dt><strong><code>extra</code></strong> :&ensp;<code>dict</code></dt>
<dd>The extra attribute contains all extra parameters configured in the action.</dd>
<dt><strong><code>provider</code></strong> :&ensp;<code>dict</code></dt>
<dd>If use_provider is true on the configured action, the provider attribute contains the provider parameters. The provider parameters are available under the parms
object as well under the "provider" key.</dd>
<dt><strong><code>logger</code></strong> :&ensp;<code><a title="amps.Logger" href="#amps.Logger">Logger</a></code></dt>
<dd>The logger attribute exposes a Logger object for logging events back to AMPS. Any messages logged using this object during the action execution will appear in the corresponding session logs.</dd>
</dl>
<p>Usage:</p>
<pre><code>from amps import Action
class my_action(Action):
    def action(self):
        # Get Message Data (This example assumes inline).
        data = self.msg[&quot;data&quot;]
        # Perform Action Logic Here
        if success:
            self.logger.info(&quot;Successfully Processed Message&quot;)
            return Action.send_status(&quot;completed&quot;)
        else:
            self.logger.warn(&quot;Failed to process message&quot;)
            return Action.send_status(&quot;failed&quot;, &quot;Reason for Failure&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Action:
    &#34;&#34;&#34;The `Action` class from AMPS provides a base class for actions that must be extended in a custom action. Actions can be performed by overriding the `Action.action` callback exposed by the class.

    Attributes:
        msg (dict): The msg attribute contains a python of the dictionary and the message with all of its metadata. Message data can be accessed from the msg attribute, either using the &#34;data&#34; key for inline data, or the &#34;fpath&#34; key for a path to the file containing the data.
        parms (dict): The parms attribute contains all the parameters of the configured action including any extra parameters you may have specified under the &#34;parms&#34; key.
        sysparms (dict): The sysparms attribute contains all useful system configuration parameters for use in actions. Currently, sysparms only contains the AMPS temporary directory under the &#34;tempdir&#34; key.
        extra (dict): The extra attribute contains all extra parameters configured in the action.
        provider (dict): If use_provider is true on the configured action, the provider attribute contains the provider parameters. The provider parameters are available under the parms  object as well under the &#34;provider&#34; key.
        logger (Logger): The logger attribute exposes a Logger object for logging events back to AMPS. Any messages logged using this object during the action execution will appear in the corresponding session logs.

    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            # Get Message Data (This example assumes inline).
            data = self.msg[&#34;data&#34;]
            # Perform Action Logic Here
            if success:
                self.logger.info(&#34;Successfully Processed Message&#34;)
                return Action.send_status(&#34;completed&#34;)
            else:
                self.logger.warn(&#34;Failed to process message&#34;)
                return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
    ```
    &#34;&#34;&#34;

    def __init__(self, msgdata):
        msgdata = json.loads(msgdata)
        self.msg = msgdata[&#34;msg&#34;]
        self.parms = msgdata[&#34;parms&#34;]
        self.sysparms = msgdata[&#34;sysparms&#34;]
        self.extra = self.parms[&#34;parms&#34;]
        self.env = self.parms[&#34;env&#34;]
        self.db = DB(self.env)
        self.users = Users(self.env)

        if self.parms[&#34;use_provider&#34;]:
            self.provider = self.parms[&#34;provider&#34;]
        if self.msg.get(&#34;sid&#34;):
            self.logger = Logger(sid=self.msg[&#34;sid&#34;])
        else:
            self.logger = Logger()

    def __run__(self):
        try:
            response = self.action()
        except Exception as e:
            response = {&#34;error&#34;: True, &#34;reason&#34;: str(e)}
        return json.dumps(response)

    def action(self):
        &#34;&#34;&#34;Callback to override in order to perform action logic in a class that extends `Action`.

        Relevant message data is available via the attributes available on the self object. It expects the method to return a python dictionary with at least a &#34;status&#34; key with the status of the action execution. If the action execution is unsuccessful, a &#34;reason&#34; key can also be returned along with an unsuccessful status. If a new message is intended to be created by this action, it is also expected that a &#34;msg&#34; key will be returned with a dictionary object containing either a &#34;data&#34; key with inline data or an &#34;fpath&#34; key containing the file path to the message. Similarly, actions used in Endpoints can return a &#34;response&#34; object with the response status code specified under the &#34;code&#34; key, and the response body provided via either the &#34;data&#34; or &#34;fpath&#34; key. The action method is automatically wrapped in a try-except block when it is called, so is unnecessary to wrap the overall method in a try-except block. If you wish to have more granular visibility over errors that arise in your actions, feel free to use try-except blocks at various steps throughout action execution to allow for logging specific reasons for failure. To simplify action creation and handling, a number of helper methods are exposed by the class as static methods.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                if success:
                    return Action.send_status(&#34;completed&#34;)
                else:
                    return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
        ```
        &#34;&#34;&#34;
        return {&#34;status&#34;: &#34;completed&#34;}

    def get_data(self):
        &#34;&#34;&#34;Convenience method to read get string data from message.

        Returns either the inline message data stored on the &#34;data&#34; key or the data stored in the message&#39;s file via the &#34;fpath&#34; key.
        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                data = self.get_data()
                # Use data here
                if success:
                    return Action.send_status(&#34;completed&#34;)
                else:
                    return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
        ```
        &#34;&#34;&#34;
        if self.msg.get(&#34;data&#34;):
            return self.msg[&#34;data&#34;]
        else:
            return open(self.msg[&#34;fpath&#34;]).read()

    @staticmethod
    def send_async(status, key, data):
        &#34;&#34;&#34;Static method for creating a dictionary with the provided status and an async key with the provided data for asynchronously returning from an API endpoint.

        Args:
            status (string): The Action status to log.
            key (string): The key to use for this data when returning the json object.
            data (string || dict): Either a string containing the response data or a dictionary which will be JSON encoded and return.

        This convenience method allows for returning data asynchronously from a script when used in an API Endpoint-triggered topic workflow.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                if success:
                    return Action.send_async(&#34;completed&#34;, &#34;Hello, this is my async response.&#34;)
                else:
                    return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
        ```
        &#34;&#34;&#34;
        return {&#34;status&#34;: status, &#34;async&#34;: {key: data}}

    @staticmethod
    def send_status(status: str, reason: str = None):
        &#34;&#34;&#34;Static method for creating a dictionary with the provided status and optional reason for returning in the `action` callback.

        Args:
            status (string): The Action status to log.
            reason (string): An optional reason to provide along with the given status.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                if success:
                    return Action.send_status(&#34;completed&#34;)
                else:
                    return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
        ```
        &#34;&#34;&#34;
        if reason:
            return {&#34;status&#34;: status, &#34;reason&#34;: reason}
        else:
            return {&#34;status&#34;: status}

    @staticmethod
    def send_file(status: str, fpath: str, meta: dict = {}):
        &#34;&#34;&#34;Static method for creating a dictionary with the provided status and a new message from the provided fpath and additional metadata for returning in the `Action.action` callback.

        Args:
            status (string): The Action status to log.
            fpath (string): A filepath to a file containing the message data.
            meta (dict): An optional dictionary containing additional metadata to add to the new message.

        This convenience method allows for the creation of a new message using the file specified in `fpath` and any additional metadata supplied in `meta`. File Size (fsize) and File Name (fname) are automatically retrieved from the given file.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                if success:
                    return Action.send_file(&#34;completed&#34;, &#34;path/to/file&#34;, {&#34;partner&#34;: &#34;companyX&#34;})
                else:
                    return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
        ```
        &#34;&#34;&#34;
        fname = os.path.basename(fpath)
        fsize = os.path.getsize(fpath)
        msg = {**{&#34;fname&#34;: fname, &#34;fsize&#34;: fsize, &#34;fpath&#34;: fpath}, **meta}
        return {&#34;status&#34;: status, &#34;msg&#34;: msg}

    @staticmethod
    def send_data(status: str, data: str, meta: dict = {}):
        &#34;&#34;&#34;Static method for creating a dictionary with the provided status and a new message with the provided inline data and additional metadata for returning in the `action` callback.

        Args:
            status (string): The Action status to log.
            fpath (string): A string containing the message data.
            meta (dict): An optional dictionary containing additional metadata to add to the new message.

        This convenience method allows for the creation of a new message using the inline data specified in `data` and any additional metadata supplied in `meta`.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                if success:
                    return Action.send_data(&#34;completed&#34;, &#34;Hello, this is my inline data.&#34;, {&#34;partner&#34;: &#34;companyX&#34;})
                else:
                    return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
        ```
        &#34;&#34;&#34;
        msg = {**{&#34;data&#34;: data}, **meta}
        return {&#34;status&#34;: status, &#34;msg&#34;: msg}

    @staticmethod
    def send_error(reason: str):
        &#34;&#34;&#34;Static method for handling errors by creating a dictionary with a ``failed`` status and the provided reason for returning in the `Action.action` callback.

        Args:
            reason (string): The reason for the action failure.

        This convenience method allows for the quick handling of error using the default ``failed`` status along with the reason specified in :param`reason`.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                if success:
                    return Action.send_status(&#34;completed&#34;)
                else:
                    return Action.send_error(&#34;Reason for Failure&#34;)
        ```
        &#34;&#34;&#34;
        return {&#34;status&#34;: &#34;failed&#34;, &#34;reason&#34;: reason}</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="amps.Endpoint" href="#amps.Endpoint">Endpoint</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="amps.Action.send_async"><code class="name flex">
<span>def <span class="ident">send_async</span></span>(<span>status, key, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Static method for creating a dictionary with the provided status and an async key with the provided data for asynchronously returning from an API endpoint.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>string</code></dt>
<dd>The Action status to log.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>The key to use for this data when returning the json object.</dd>
</dl>
<p>data (string || dict): Either a string containing the response data or a dictionary which will be JSON encoded and return.
This convenience method allows for returning data asynchronously from a script when used in an API Endpoint-triggered topic workflow.</p>
<p>Usage:</p>
<pre><code>from amps import Action
class my_action(Action):
    def action(self):
        # Perform Action Logic Here
        if success:
            return Action.send_async(&quot;completed&quot;, &quot;Hello, this is my async response.&quot;)
        else:
            return Action.send_status(&quot;failed&quot;, &quot;Reason for Failure&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def send_async(status, key, data):
    &#34;&#34;&#34;Static method for creating a dictionary with the provided status and an async key with the provided data for asynchronously returning from an API endpoint.

    Args:
        status (string): The Action status to log.
        key (string): The key to use for this data when returning the json object.
        data (string || dict): Either a string containing the response data or a dictionary which will be JSON encoded and return.

    This convenience method allows for returning data asynchronously from a script when used in an API Endpoint-triggered topic workflow.

    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            # Perform Action Logic Here
            if success:
                return Action.send_async(&#34;completed&#34;, &#34;Hello, this is my async response.&#34;)
            else:
                return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
    ```
    &#34;&#34;&#34;
    return {&#34;status&#34;: status, &#34;async&#34;: {key: data}}</code></pre>
</details>
</dd>
<dt id="amps.Action.send_data"><code class="name flex">
<span>def <span class="ident">send_data</span></span>(<span>status:str, data:str, meta:dict={})</span>
</code></dt>
<dd>
<div class="desc"><p>Static method for creating a dictionary with the provided status and a new message with the provided inline data and additional metadata for returning in the <code>action</code> callback.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>string</code></dt>
<dd>The Action status to log.</dd>
<dt><strong><code>fpath</code></strong> :&ensp;<code>string</code></dt>
<dd>A string containing the message data.</dd>
<dt><strong><code>meta</code></strong> :&ensp;<code>dict</code></dt>
<dd>An optional dictionary containing additional metadata to add to the new message.</dd>
</dl>
<p>This convenience method allows for the creation of a new message using the inline data specified in <code>data</code> and any additional metadata supplied in <code>meta</code>.</p>
<p>Usage:</p>
<pre><code>from amps import Action
class my_action(Action):
    def action(self):
        # Perform Action Logic Here
        if success:
            return Action.send_data(&quot;completed&quot;, &quot;Hello, this is my inline data.&quot;, {&quot;partner&quot;: &quot;companyX&quot;})
        else:
            return Action.send_status(&quot;failed&quot;, &quot;Reason for Failure&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def send_data(status: str, data: str, meta: dict = {}):
    &#34;&#34;&#34;Static method for creating a dictionary with the provided status and a new message with the provided inline data and additional metadata for returning in the `action` callback.

    Args:
        status (string): The Action status to log.
        fpath (string): A string containing the message data.
        meta (dict): An optional dictionary containing additional metadata to add to the new message.

    This convenience method allows for the creation of a new message using the inline data specified in `data` and any additional metadata supplied in `meta`.

    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            # Perform Action Logic Here
            if success:
                return Action.send_data(&#34;completed&#34;, &#34;Hello, this is my inline data.&#34;, {&#34;partner&#34;: &#34;companyX&#34;})
            else:
                return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
    ```
    &#34;&#34;&#34;
    msg = {**{&#34;data&#34;: data}, **meta}
    return {&#34;status&#34;: status, &#34;msg&#34;: msg}</code></pre>
</details>
</dd>
<dt id="amps.Action.send_error"><code class="name flex">
<span>def <span class="ident">send_error</span></span>(<span>reason:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Static method for handling errors by creating a dictionary with a <code>failed</code> status and the provided reason for returning in the <code><a title="amps.Action.action" href="#amps.Action.action">Action.action()</a></code> callback.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code>string</code></dt>
<dd>The reason for the action failure.</dd>
</dl>
<p>This convenience method allows for the quick handling of error using the default <code>failed</code> status along with the reason specified in :param<code>reason</code>.</p>
<p>Usage:</p>
<pre><code>from amps import Action
class my_action(Action):
    def action(self):
        # Perform Action Logic Here
        if success:
            return Action.send_status(&quot;completed&quot;)
        else:
            return Action.send_error(&quot;Reason for Failure&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def send_error(reason: str):
    &#34;&#34;&#34;Static method for handling errors by creating a dictionary with a ``failed`` status and the provided reason for returning in the `Action.action` callback.

    Args:
        reason (string): The reason for the action failure.

    This convenience method allows for the quick handling of error using the default ``failed`` status along with the reason specified in :param`reason`.

    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            # Perform Action Logic Here
            if success:
                return Action.send_status(&#34;completed&#34;)
            else:
                return Action.send_error(&#34;Reason for Failure&#34;)
    ```
    &#34;&#34;&#34;
    return {&#34;status&#34;: &#34;failed&#34;, &#34;reason&#34;: reason}</code></pre>
</details>
</dd>
<dt id="amps.Action.send_file"><code class="name flex">
<span>def <span class="ident">send_file</span></span>(<span>status:str, fpath:str, meta:dict={})</span>
</code></dt>
<dd>
<div class="desc"><p>Static method for creating a dictionary with the provided status and a new message from the provided fpath and additional metadata for returning in the <code><a title="amps.Action.action" href="#amps.Action.action">Action.action()</a></code> callback.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>string</code></dt>
<dd>The Action status to log.</dd>
<dt><strong><code>fpath</code></strong> :&ensp;<code>string</code></dt>
<dd>A filepath to a file containing the message data.</dd>
<dt><strong><code>meta</code></strong> :&ensp;<code>dict</code></dt>
<dd>An optional dictionary containing additional metadata to add to the new message.</dd>
</dl>
<p>This convenience method allows for the creation of a new message using the file specified in <code>fpath</code> and any additional metadata supplied in <code>meta</code>. File Size (fsize) and File Name (fname) are automatically retrieved from the given file.</p>
<p>Usage:</p>
<pre><code>from amps import Action
class my_action(Action):
    def action(self):
        # Perform Action Logic Here
        if success:
            return Action.send_file(&quot;completed&quot;, &quot;path/to/file&quot;, {&quot;partner&quot;: &quot;companyX&quot;})
        else:
            return Action.send_status(&quot;failed&quot;, &quot;Reason for Failure&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def send_file(status: str, fpath: str, meta: dict = {}):
    &#34;&#34;&#34;Static method for creating a dictionary with the provided status and a new message from the provided fpath and additional metadata for returning in the `Action.action` callback.

    Args:
        status (string): The Action status to log.
        fpath (string): A filepath to a file containing the message data.
        meta (dict): An optional dictionary containing additional metadata to add to the new message.

    This convenience method allows for the creation of a new message using the file specified in `fpath` and any additional metadata supplied in `meta`. File Size (fsize) and File Name (fname) are automatically retrieved from the given file.

    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            # Perform Action Logic Here
            if success:
                return Action.send_file(&#34;completed&#34;, &#34;path/to/file&#34;, {&#34;partner&#34;: &#34;companyX&#34;})
            else:
                return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
    ```
    &#34;&#34;&#34;
    fname = os.path.basename(fpath)
    fsize = os.path.getsize(fpath)
    msg = {**{&#34;fname&#34;: fname, &#34;fsize&#34;: fsize, &#34;fpath&#34;: fpath}, **meta}
    return {&#34;status&#34;: status, &#34;msg&#34;: msg}</code></pre>
</details>
</dd>
<dt id="amps.Action.send_status"><code class="name flex">
<span>def <span class="ident">send_status</span></span>(<span>status:str, reason:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Static method for creating a dictionary with the provided status and optional reason for returning in the <code>action</code> callback.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>string</code></dt>
<dd>The Action status to log.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code>string</code></dt>
<dd>An optional reason to provide along with the given status.</dd>
</dl>
<p>Usage:</p>
<pre><code>from amps import Action
class my_action(Action):
    def action(self):
        # Perform Action Logic Here
        if success:
            return Action.send_status(&quot;completed&quot;)
        else:
            return Action.send_status(&quot;failed&quot;, &quot;Reason for Failure&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def send_status(status: str, reason: str = None):
    &#34;&#34;&#34;Static method for creating a dictionary with the provided status and optional reason for returning in the `action` callback.

    Args:
        status (string): The Action status to log.
        reason (string): An optional reason to provide along with the given status.

    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            # Perform Action Logic Here
            if success:
                return Action.send_status(&#34;completed&#34;)
            else:
                return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
    ```
    &#34;&#34;&#34;
    if reason:
        return {&#34;status&#34;: status, &#34;reason&#34;: reason}
    else:
        return {&#34;status&#34;: status}</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="amps.Action.action"><code class="name flex">
<span>def <span class="ident">action</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback to override in order to perform action logic in a class that extends <code><a title="amps.Action" href="#amps.Action">Action</a></code>.</p>
<p>Relevant message data is available via the attributes available on the self object. It expects the method to return a python dictionary with at least a "status" key with the status of the action execution. If the action execution is unsuccessful, a "reason" key can also be returned along with an unsuccessful status. If a new message is intended to be created by this action, it is also expected that a "msg" key will be returned with a dictionary object containing either a "data" key with inline data or an "fpath" key containing the file path to the message. Similarly, actions used in Endpoints can return a "response" object with the response status code specified under the "code" key, and the response body provided via either the "data" or "fpath" key. The action method is automatically wrapped in a try-except block when it is called, so is unnecessary to wrap the overall method in a try-except block. If you wish to have more granular visibility over errors that arise in your actions, feel free to use try-except blocks at various steps throughout action execution to allow for logging specific reasons for failure. To simplify action creation and handling, a number of helper methods are exposed by the class as static methods.</p>
<p>Usage:</p>
<pre><code>from amps import Action
class my_action(Action):
    def action(self):
        # Perform Action Logic Here
        if success:
            return Action.send_status(&quot;completed&quot;)
        else:
            return Action.send_status(&quot;failed&quot;, &quot;Reason for Failure&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def action(self):
    &#34;&#34;&#34;Callback to override in order to perform action logic in a class that extends `Action`.

    Relevant message data is available via the attributes available on the self object. It expects the method to return a python dictionary with at least a &#34;status&#34; key with the status of the action execution. If the action execution is unsuccessful, a &#34;reason&#34; key can also be returned along with an unsuccessful status. If a new message is intended to be created by this action, it is also expected that a &#34;msg&#34; key will be returned with a dictionary object containing either a &#34;data&#34; key with inline data or an &#34;fpath&#34; key containing the file path to the message. Similarly, actions used in Endpoints can return a &#34;response&#34; object with the response status code specified under the &#34;code&#34; key, and the response body provided via either the &#34;data&#34; or &#34;fpath&#34; key. The action method is automatically wrapped in a try-except block when it is called, so is unnecessary to wrap the overall method in a try-except block. If you wish to have more granular visibility over errors that arise in your actions, feel free to use try-except blocks at various steps throughout action execution to allow for logging specific reasons for failure. To simplify action creation and handling, a number of helper methods are exposed by the class as static methods.

    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            # Perform Action Logic Here
            if success:
                return Action.send_status(&#34;completed&#34;)
            else:
                return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
    ```
    &#34;&#34;&#34;
    return {&#34;status&#34;: &#34;completed&#34;}</code></pre>
</details>
</dd>
<dt id="amps.Action.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience method to read get string data from message.</p>
<p>Returns either the inline message data stored on the "data" key or the data stored in the message's file via the "fpath" key.
Usage:</p>
<pre><code>from amps import Action
class my_action(Action):
    def action(self):
        # Perform Action Logic Here
        data = self.get_data()
        # Use data here
        if success:
            return Action.send_status(&quot;completed&quot;)
        else:
            return Action.send_status(&quot;failed&quot;, &quot;Reason for Failure&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self):
    &#34;&#34;&#34;Convenience method to read get string data from message.

    Returns either the inline message data stored on the &#34;data&#34; key or the data stored in the message&#39;s file via the &#34;fpath&#34; key.
    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            # Perform Action Logic Here
            data = self.get_data()
            # Use data here
            if success:
                return Action.send_status(&#34;completed&#34;)
            else:
                return Action.send_status(&#34;failed&#34;, &#34;Reason for Failure&#34;)
    ```
    &#34;&#34;&#34;
    if self.msg.get(&#34;data&#34;):
        return self.msg[&#34;data&#34;]
    else:
        return open(self.msg[&#34;fpath&#34;]).read()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="amps.DB"><code class="flex name class">
<span>class <span class="ident">DB</span></span>
<span>(</span><span>env)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DB:
    def __init__(self, env):
        self.env = env

    def find(self, collection, clauses={}, opts={}):
        coll = bytes(collection, &#34;utf-8&#34;)
        collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
            b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
        clauses = Map(clauses)
        opts = Map(opts)
        result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                      Atom(b&#39;find&#39;), [collection, clauses, opts])
        return Util.unravel_erlport_object(result)

    def find_one(self, collection, clauses={}, opts={}):
        coll = bytes(collection, &#34;utf-8&#34;)
        collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
            b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
        clauses = Map(clauses)
        opts = Map(opts)
        result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                      Atom(b&#39;find_one&#39;), [collection, clauses, opts])
        return Util.unravel_erlport_object(result)

    def create(self, collection, body):
        coll = bytes(collection, &#34;utf-8&#34;)
        collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
            b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
        body = Map(body)
        result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                      Atom(b&#39;create&#39;), [collection, body])
        return Util.unravel_erlport_object(result)

    def update(self, collection, body, id):
        coll = bytes(collection, &#34;utf-8&#34;)
        id = bytes(id, &#34;utf-8&#34;)
        collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
            b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
        body = Map(body)
        result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                      Atom(b&#39;update&#39;), [collection, body, id])
        return Util.unravel_erlport_object(result)

    def delete(self, collection, id):
        coll = bytes(collection, &#34;utf-8&#34;)
        id = bytes(id, &#34;utf-8&#34;)
        collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
            b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
        result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                      Atom(b&#39;delete&#39;), [collection, id])
        return Util.unravel_erlport_object(result)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="amps.DB.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, collection, body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, collection, body):
    coll = bytes(collection, &#34;utf-8&#34;)
    collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
        b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
    body = Map(body)
    result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                  Atom(b&#39;create&#39;), [collection, body])
    return Util.unravel_erlport_object(result)</code></pre>
</details>
</dd>
<dt id="amps.DB.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, collection, id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, collection, id):
    coll = bytes(collection, &#34;utf-8&#34;)
    id = bytes(id, &#34;utf-8&#34;)
    collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
        b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
    result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                  Atom(b&#39;delete&#39;), [collection, id])
    return Util.unravel_erlport_object(result)</code></pre>
</details>
</dd>
<dt id="amps.DB.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, collection, clauses={}, opts={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, collection, clauses={}, opts={}):
    coll = bytes(collection, &#34;utf-8&#34;)
    collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
        b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
    clauses = Map(clauses)
    opts = Map(opts)
    result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                  Atom(b&#39;find&#39;), [collection, clauses, opts])
    return Util.unravel_erlport_object(result)</code></pre>
</details>
</dd>
<dt id="amps.DB.find_one"><code class="name flex">
<span>def <span class="ident">find_one</span></span>(<span>self, collection, clauses={}, opts={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_one(self, collection, clauses={}, opts={}):
    coll = bytes(collection, &#34;utf-8&#34;)
    collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
        b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
    clauses = Map(clauses)
    opts = Map(opts)
    result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                  Atom(b&#39;find_one&#39;), [collection, clauses, opts])
    return Util.unravel_erlport_object(result)</code></pre>
</details>
</dd>
<dt id="amps.DB.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, collection, body, id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, collection, body, id):
    coll = bytes(collection, &#34;utf-8&#34;)
    id = bytes(id, &#34;utf-8&#34;)
    collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
        b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
    body = Map(body)
    result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                  Atom(b&#39;update&#39;), [collection, body, id])
    return Util.unravel_erlport_object(result)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="amps.Endpoint"><code class="flex name class">
<span>class <span class="ident">Endpoint</span></span>
<span>(</span><span>msgdata)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="amps.Endpoint" href="#amps.Endpoint">Endpoint</a></code> class from AMPS extends the <code><a title="amps.Action" href="#amps.Action">Action</a></code> class to provide additional convenience in setting up API endpoint actions. Like regular actions, endpoint actions can be performed by overriding the <code><a title="amps.Action.action" href="#amps.Action.action">Action.action()</a></code> callback exposed by the class.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>msg</code></strong> :&ensp;<code>dict</code></dt>
<dd>The msg attribute contains a python of the dictionary and the message with all of its metadata. Message data can be accessed from the msg attribute, either using the "data" key for inline data, or the "fpath" key for a path to the file containing the data.</dd>
<dt><strong><code>parms</code></strong> :&ensp;<code>dict</code></dt>
<dd>The parms attribute contains all the parameters of the configured action including any extra parameters you may have specified under the "parms" key.</dd>
<dt><strong><code>sysparms</code></strong> :&ensp;<code>dict</code></dt>
<dd>The sysparms attribute contains all useful system configuration parameters for use in actions. Currently, sysparms only contains the AMPS temporary directory under the "tempdir" key.</dd>
<dt><strong><code>provider</code></strong> :&ensp;<code>dict</code></dt>
<dd>If use_provider is true on the configured action, the provider attribute contains the provider parameters. The provider parameters are available under the parms
object as well under the "provider" key.</dd>
<dt><strong><code>logger</code></strong> :&ensp;<code><a title="amps.Logger" href="#amps.Logger">Logger</a></code></dt>
<dd>The logger attribute exposes a Logger object for logging events back to AMPS. Any messages logged using this object during the action execution will appear in the corresponding session logs.</dd>
<dt><strong><code>path_params</code></strong> :&ensp;<code>dict</code></dt>
<dd>The path_params attribute contains any parameters that were passed to the endpoint via the URL. It is also available on the <code>msg</code> attribute via the "path_params" key.</dd>
<dt><strong><code>query_params</code></strong> :&ensp;<code>dict</code></dt>
<dd>The query_params attribute contains any parameters that were passed to the endpoint via the query parameters. It is also available on the <code>msg</code> attribute via the "query_params" key.</dd>
</dl>
<p>Unlike actions, which are typically performed asynchronous via topic workflows, because Endpoints are called synchronously, if the endpoint action executes successfully, but produces an erroneous state, the action should return a successful status with the appropriate error code and response body under the "response" key.</p>
<p>Usage:</p>
<pre><code>from amps import Endpoint
class my_endpoint(Endpoint):
    def action(self):
        # Perform Endpoint Logic Here
        if success:
            return Endpoint.send_resp_file(&quot;path/to/file&quot;, 200)
        else:
            return Endpoint.send_resp_data(&quot;File not found.&quot;, 404)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Endpoint(Action):
    &#34;&#34;&#34;The `Endpoint` class from AMPS extends the `Action` class to provide additional convenience in setting up API endpoint actions. Like regular actions, endpoint actions can be performed by overriding the `Action.action` callback exposed by the class.

    Attributes:
        msg (dict): The msg attribute contains a python of the dictionary and the message with all of its metadata. Message data can be accessed from the msg attribute, either using the &#34;data&#34; key for inline data, or the &#34;fpath&#34; key for a path to the file containing the data.
        parms (dict): The parms attribute contains all the parameters of the configured action including any extra parameters you may have specified under the &#34;parms&#34; key.
        sysparms (dict): The sysparms attribute contains all useful system configuration parameters for use in actions. Currently, sysparms only contains the AMPS temporary directory under the &#34;tempdir&#34; key.
        provider (dict): If use_provider is true on the configured action, the provider attribute contains the provider parameters. The provider parameters are available under the parms  object as well under the &#34;provider&#34; key.
        logger (Logger): The logger attribute exposes a Logger object for logging events back to AMPS. Any messages logged using this object during the action execution will appear in the corresponding session logs.
        path_params (dict): The path_params attribute contains any parameters that were passed to the endpoint via the URL. It is also available on the `msg` attribute via the &#34;path_params&#34; key.
        query_params (dict): The query_params attribute contains any parameters that were passed to the endpoint via the query parameters. It is also available on the `msg` attribute via the &#34;query_params&#34; key.

    Unlike actions, which are typically performed asynchronous via topic workflows, because Endpoints are called synchronously, if the endpoint action executes successfully, but produces an erroneous state, the action should return a successful status with the appropriate error code and response body under the &#34;response&#34; key.

    Usage:
    ```
    from amps import Endpoint
    class my_endpoint(Endpoint):
        def action(self):
            # Perform Endpoint Logic Here
            if success:
                return Endpoint.send_resp_file(&#34;path/to/file&#34;, 200)
            else:
                return Endpoint.send_resp_data(&#34;File not found.&#34;, 404)
    ```
    &#34;&#34;&#34;

    def __init__(self, msgdata):
        super().__init__(msgdata)
        self.path_params = self.msg.get(&#34;path_params&#34;)
        self.query_params = self.msg.get(&#34;query_params&#34;)

    def send_resp_data(data: str, code: int):
        &#34;&#34;&#34;Static method for creating a dictionary with the provided inline data and status code in the &#34;response&#34; object for returning in the `Action.action` callback.

        Args:
            data (string): The inline data to supply in the response body.
            code (integer): An integer containing the response status code to set.

        Usage:
        ```
        from amps import Endpoint
        import json
        class my_endpoint(Endpoint):
            def action(self):
                # Perform Endpoint Logic Here
                if success:
                    return Endpoint.send_resp_data(json.dumps({&#34;id&#34;: 1, &#34;name&#34;: &#34;Test User&#34;}), 200)
                else:
                    return Endpoint.send_resp_data(&#34;User not found.&#34;, 404)
        ```
        &#34;&#34;&#34;
        return {&#34;status&#34;: &#34;completed&#34;, &#34;response&#34;: {&#34;data&#34;: data, &#34;code&#34;: code}}

    def send_resp_file(fpath, code):
        &#34;&#34;&#34;Static method for creating a dictionary with the provided file path and status code in the &#34;response&#34; object for returning in the `Action.action` callback.

        Args:
            fpath (string): The path to file to send in the response body.
            code (integer): An integer containing the response status code to set.

        This convenience method allows for the convenient sending of a file in the response of a request along with the specified status code.

        Usage:
        ```
        from amps import Endpoint
        class my_endpoint(Endpoint):
            def action(self):
                # Perform Endpoint Logic Here
                if success:
                    return Endpoint.send_resp_file(&#34;path/to/file&#34;, 200)
                else:
                    return Endpoint.send_resp_data(&#34;File not found.&#34;, 404)
        ```
        &#34;&#34;&#34;
        return {&#34;status&#34;: &#34;completed&#34;, &#34;response&#34;: {&#34;fpath&#34;: fpath, &#34;code&#34;: code}}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="amps.Action" href="#amps.Action">Action</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="amps.Endpoint.send_resp_data"><code class="name flex">
<span>def <span class="ident">send_resp_data</span></span>(<span>data:str, code:int)</span>
</code></dt>
<dd>
<div class="desc"><p>Static method for creating a dictionary with the provided inline data and status code in the "response" object for returning in the <code><a title="amps.Action.action" href="#amps.Action.action">Action.action()</a></code> callback.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>string</code></dt>
<dd>The inline data to supply in the response body.</dd>
<dt><strong><code>code</code></strong> :&ensp;<code>integer</code></dt>
<dd>An integer containing the response status code to set.</dd>
</dl>
<p>Usage:</p>
<pre><code>from amps import Endpoint
import json
class my_endpoint(Endpoint):
    def action(self):
        # Perform Endpoint Logic Here
        if success:
            return Endpoint.send_resp_data(json.dumps({&quot;id&quot;: 1, &quot;name&quot;: &quot;Test User&quot;}), 200)
        else:
            return Endpoint.send_resp_data(&quot;User not found.&quot;, 404)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_resp_data(data: str, code: int):
    &#34;&#34;&#34;Static method for creating a dictionary with the provided inline data and status code in the &#34;response&#34; object for returning in the `Action.action` callback.

    Args:
        data (string): The inline data to supply in the response body.
        code (integer): An integer containing the response status code to set.

    Usage:
    ```
    from amps import Endpoint
    import json
    class my_endpoint(Endpoint):
        def action(self):
            # Perform Endpoint Logic Here
            if success:
                return Endpoint.send_resp_data(json.dumps({&#34;id&#34;: 1, &#34;name&#34;: &#34;Test User&#34;}), 200)
            else:
                return Endpoint.send_resp_data(&#34;User not found.&#34;, 404)
    ```
    &#34;&#34;&#34;
    return {&#34;status&#34;: &#34;completed&#34;, &#34;response&#34;: {&#34;data&#34;: data, &#34;code&#34;: code}}</code></pre>
</details>
</dd>
<dt id="amps.Endpoint.send_resp_file"><code class="name flex">
<span>def <span class="ident">send_resp_file</span></span>(<span>fpath, code)</span>
</code></dt>
<dd>
<div class="desc"><p>Static method for creating a dictionary with the provided file path and status code in the "response" object for returning in the <code><a title="amps.Action.action" href="#amps.Action.action">Action.action()</a></code> callback.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fpath</code></strong> :&ensp;<code>string</code></dt>
<dd>The path to file to send in the response body.</dd>
<dt><strong><code>code</code></strong> :&ensp;<code>integer</code></dt>
<dd>An integer containing the response status code to set.</dd>
</dl>
<p>This convenience method allows for the convenient sending of a file in the response of a request along with the specified status code.</p>
<p>Usage:</p>
<pre><code>from amps import Endpoint
class my_endpoint(Endpoint):
    def action(self):
        # Perform Endpoint Logic Here
        if success:
            return Endpoint.send_resp_file(&quot;path/to/file&quot;, 200)
        else:
            return Endpoint.send_resp_data(&quot;File not found.&quot;, 404)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_resp_file(fpath, code):
    &#34;&#34;&#34;Static method for creating a dictionary with the provided file path and status code in the &#34;response&#34; object for returning in the `Action.action` callback.

    Args:
        fpath (string): The path to file to send in the response body.
        code (integer): An integer containing the response status code to set.

    This convenience method allows for the convenient sending of a file in the response of a request along with the specified status code.

    Usage:
    ```
    from amps import Endpoint
    class my_endpoint(Endpoint):
        def action(self):
            # Perform Endpoint Logic Here
            if success:
                return Endpoint.send_resp_file(&#34;path/to/file&#34;, 200)
            else:
                return Endpoint.send_resp_data(&#34;File not found.&#34;, 404)
    ```
    &#34;&#34;&#34;
    return {&#34;status&#34;: &#34;completed&#34;, &#34;response&#34;: {&#34;fpath&#34;: fpath, &#34;code&#34;: code}}</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="amps.Action" href="#amps.Action">Action</a></b></code>:
<ul class="hlist">
<li><code><a title="amps.Action.action" href="#amps.Action.action">action</a></code></li>
<li><code><a title="amps.Action.get_data" href="#amps.Action.get_data">get_data</a></code></li>
<li><code><a title="amps.Action.send_async" href="#amps.Action.send_async">send_async</a></code></li>
<li><code><a title="amps.Action.send_data" href="#amps.Action.send_data">send_data</a></code></li>
<li><code><a title="amps.Action.send_error" href="#amps.Action.send_error">send_error</a></code></li>
<li><code><a title="amps.Action.send_file" href="#amps.Action.send_file">send_file</a></code></li>
<li><code><a title="amps.Action.send_status" href="#amps.Action.send_status">send_status</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="amps.Logger"><code class="flex name class">
<span>class <span class="ident">Logger</span></span>
<span>(</span><span>sid='', service=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="amps.Logger" href="#amps.Logger">Logger</a></code> class from AMPS is a utility class for logging events back to AMPS. This class should not be used directly, but rather instances of this class within Actions, Endpoints, and Services should be used.</p>
<p>Usage:</p>
<pre><code>from amps import Action
class my_action(Action):
    def action(self):
        self.logger.info(&quot;Action Execution Started&quot;)
        # Perform Action Logic Here
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Logger:
    &#34;&#34;&#34;The `Logger` class from AMPS is a utility class for logging events back to AMPS. This class should not be used directly, but rather instances of this class within Actions, Endpoints, and Services should be used.

    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            self.logger.info(&#34;Action Execution Started&#34;)
            # Perform Action Logic Here
    ```
    &#34;&#34;&#34;

    def __init__(self, sid=&#34;&#34;, service=None):
        self.__sid__ = sid
        self.__service__ = service

    def log(self, level: str, message: str):
        &#34;&#34;&#34;Instance method that logs a given message with the given level.

        Args:
            level (string): The level to use when logging the given message. All valid &#34;level&#34; values are available in the docs for the [Logger](https://hexdocs.pm/logger/1.13/Logger.html#module-levels) Elixir library underlying this class.
            message (string): The message to log.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                self.logger.log(&#34;info&#34;, &#34;Action Execution Started&#34;)
                # Perform Action Logic Here
        ```
        &#34;&#34;&#34;
        if self.__service__:
            self.__service__.__log__(Atom(
                bytes(level, &#34;utf-8&#34;)), message)
        else:
            call(Atom(b&#39;Elixir.Amps.PyHandler&#39;), Atom(b&#39;log&#39;), [Atom(
                bytes(level, &#34;utf-8&#34;)), message, [(Atom(b&#39;sid&#39;), self.__sid__)]])

    def info(self, message: str):
        &#34;&#34;&#34;Instance method that logs a given message with the &#34;info&#34; level.

        Args:
            message (string): The message to log.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                self.logger.info(&#34;Action Execution Started&#34;)
                # Perform Action Logic Here
        ```
        &#34;&#34;&#34;
        self.log(&#34;info&#34;, message)

    def debug(self, message: str):
        &#34;&#34;&#34;Instance method that logs a given message with the &#34;debug&#34; level.

        Args:
            message (string): The message to log.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                self.logger.debug(&#34;Received message&#34;)
        ```
        &#34;&#34;&#34;
        self.log(&#34;debug&#34;, message)

    def warning(self, message: str):
        &#34;&#34;&#34;Instance method that logs a given message with the &#34;warning&#34; level.

        Args:
            message (string): The message to log.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                self.logger.warning(&#34;Something minor went wrong.&#34;)
        ```
        &#34;&#34;&#34;
        self.log(&#34;warning&#34;, message)

    def error(self, message: str):
        &#34;&#34;&#34;Instance method that logs a given message with the &#34;error&#34; level.

        Args:
            message (string): The message to log.

        Usage:
        ```
        from amps import Action
        class my_action(Action):
            def action(self):
                # Perform Action Logic Here
                self.logger.error(&#34;Something major went wrong.&#34;)
        ```
        &#34;&#34;&#34;
        self.log(&#34;error&#34;, message)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="amps.Logger.debug"><code class="name flex">
<span>def <span class="ident">debug</span></span>(<span>self, message:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Instance method that logs a given message with the "debug" level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>string</code></dt>
<dd>The message to log.</dd>
</dl>
<p>Usage:</p>
<pre><code>from amps import Action
class my_action(Action):
    def action(self):
        # Perform Action Logic Here
        self.logger.debug(&quot;Received message&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug(self, message: str):
    &#34;&#34;&#34;Instance method that logs a given message with the &#34;debug&#34; level.

    Args:
        message (string): The message to log.

    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            # Perform Action Logic Here
            self.logger.debug(&#34;Received message&#34;)
    ```
    &#34;&#34;&#34;
    self.log(&#34;debug&#34;, message)</code></pre>
</details>
</dd>
<dt id="amps.Logger.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>self, message:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Instance method that logs a given message with the "error" level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>string</code></dt>
<dd>The message to log.</dd>
</dl>
<p>Usage:</p>
<pre><code>from amps import Action
class my_action(Action):
    def action(self):
        # Perform Action Logic Here
        self.logger.error(&quot;Something major went wrong.&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error(self, message: str):
    &#34;&#34;&#34;Instance method that logs a given message with the &#34;error&#34; level.

    Args:
        message (string): The message to log.

    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            # Perform Action Logic Here
            self.logger.error(&#34;Something major went wrong.&#34;)
    ```
    &#34;&#34;&#34;
    self.log(&#34;error&#34;, message)</code></pre>
</details>
</dd>
<dt id="amps.Logger.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, message:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Instance method that logs a given message with the "info" level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>string</code></dt>
<dd>The message to log.</dd>
</dl>
<p>Usage:</p>
<pre><code>from amps import Action
class my_action(Action):
    def action(self):
        self.logger.info(&quot;Action Execution Started&quot;)
        # Perform Action Logic Here
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self, message: str):
    &#34;&#34;&#34;Instance method that logs a given message with the &#34;info&#34; level.

    Args:
        message (string): The message to log.

    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            self.logger.info(&#34;Action Execution Started&#34;)
            # Perform Action Logic Here
    ```
    &#34;&#34;&#34;
    self.log(&#34;info&#34;, message)</code></pre>
</details>
</dd>
<dt id="amps.Logger.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, level:str, message:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Instance method that logs a given message with the given level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>string</code></dt>
<dd>The level to use when logging the given message. All valid "level" values are available in the docs for the <a href="https://hexdocs.pm/logger/1.13/Logger.html#module-levels">Logger</a> Elixir library underlying this class.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code>string</code></dt>
<dd>The message to log.</dd>
</dl>
<p>Usage:</p>
<pre><code>from amps import Action
class my_action(Action):
    def action(self):
        self.logger.log(&quot;info&quot;, &quot;Action Execution Started&quot;)
        # Perform Action Logic Here
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(self, level: str, message: str):
    &#34;&#34;&#34;Instance method that logs a given message with the given level.

    Args:
        level (string): The level to use when logging the given message. All valid &#34;level&#34; values are available in the docs for the [Logger](https://hexdocs.pm/logger/1.13/Logger.html#module-levels) Elixir library underlying this class.
        message (string): The message to log.

    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            self.logger.log(&#34;info&#34;, &#34;Action Execution Started&#34;)
            # Perform Action Logic Here
    ```
    &#34;&#34;&#34;
    if self.__service__:
        self.__service__.__log__(Atom(
            bytes(level, &#34;utf-8&#34;)), message)
    else:
        call(Atom(b&#39;Elixir.Amps.PyHandler&#39;), Atom(b&#39;log&#39;), [Atom(
            bytes(level, &#34;utf-8&#34;)), message, [(Atom(b&#39;sid&#39;), self.__sid__)]])</code></pre>
</details>
</dd>
<dt id="amps.Logger.warning"><code class="name flex">
<span>def <span class="ident">warning</span></span>(<span>self, message:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Instance method that logs a given message with the "warning" level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>string</code></dt>
<dd>The message to log.</dd>
</dl>
<p>Usage:</p>
<pre><code>from amps import Action
class my_action(Action):
    def action(self):
        # Perform Action Logic Here
        self.logger.warning(&quot;Something minor went wrong.&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def warning(self, message: str):
    &#34;&#34;&#34;Instance method that logs a given message with the &#34;warning&#34; level.

    Args:
        message (string): The message to log.

    Usage:
    ```
    from amps import Action
    class my_action(Action):
        def action(self):
            # Perform Action Logic Here
            self.logger.warning(&#34;Something minor went wrong.&#34;)
    ```
    &#34;&#34;&#34;
    self.log(&#34;warning&#34;, message)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="amps.Service"><code class="flex name class">
<span>class <span class="ident">Service</span></span>
<span>(</span><span>parms, sysparms, pid, env, lhandler)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="amps.Service" href="#amps.Service">Service</a></code> class from AMPS provides a base class for custom python services that can be managed by AMPS, and act as both consumers of messages and producers of new messages.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>parms</code></strong> :&ensp;<code>dict</code></dt>
<dd>The parms attribute contains all the parameters of the configured service.</dd>
<dt><strong><code>sysparms</code></strong> :&ensp;<code>dict</code></dt>
<dd>The sysparms attribute contains all useful system configuration parameters for use in services. Currently, sysparms only contains the AMPS temporary directory under the "tempdir" key.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>The config attribute contains all the custom configuration provided when creating the service. All config is also available in the parms attribute under the "config" key.</dd>
<dt><strong><code>logger</code></strong> :&ensp;<code><a title="amps.Logger" href="#amps.Logger">Logger</a></code></dt>
<dd>The logger attribute exposes a Logger object for logging events back to AMPS. Any messages logged using this object during the message handling or creation will appear in the corresponding session logs.</dd>
<dt><strong><code>env</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the AMPS environment in which this service is running.</dd>
</dl>
<p>The <code><a title="amps.Service" href="#amps.Service">Service</a></code> class provides even more flexibility than the <code><a title="amps.Action" href="#amps.Action">Action</a></code> class in extending the functionality of AMPS. Unlike actions which are run and stopped, services can manage processes such as consumers/subscribers, web servers and sockets, etc, allowing the service to consume messages from and produce messages to AMPS.</p>
<p>The class exposes two callback methods, <code><a title="amps.Service.initialize" href="#amps.Service.initialize">Service.initialize()</a></code> and <code><a title="amps.Service.handle_message" href="#amps.Service.handle_message">Service.handle_message()</a></code>.
- <code>initialize</code> can be used to perform any initialization actions and start any subprocesses. Note that any subprocesses should be started in a separate thread in order to not block the main thread.
- <code>handle_message</code> can be used to receive messages from the topic specified in the service configuration.</p>
<p>The class additionally contains two methods for creating messages, <code><a title="amps.Service.send_message" href="#amps.Service.send_message">Service.send_message()</a></code> and <code><a title="amps.Service.send_new" href="#amps.Service.send_new">Service.send_new()</a></code>.
<code><a title="amps.Service.send_message" href="#amps.Service.send_message">Service.send_message()</a></code> should generally be used in handle_message in order to indicate that the message being created is stemming from the received message.
Conversely, <code><a title="amps.Service.send_new" href="#amps.Service.send_new">Service.send_new()</a></code> should be used to create new messages originating from an external source, such as a web server or consumer.</p>
<p>Usage:</p>
<pre><code>from amps import Service
class my_service(Service):
    def initialize(self):
        # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
        # Perform any other startup logic.

    def handle_message(self, msg, logger):
        # Maybe deliver this message to my subprocess or use it to process/transform the message.
        # Send a new message stemming from this message.
        self.send_message(
            msg, {&quot;data&quot;: &quot;New Message Data Here&quot;, &quot;my_custom&quot;: &quot;metadata&quot;})


</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Service:
    &#34;&#34;&#34;The `Service` class from AMPS provides a base class for custom python services that can be managed by AMPS, and act as both consumers of messages and producers of new messages.

    Attributes:
        parms (dict): The parms attribute contains all the parameters of the configured service.
        sysparms (dict): The sysparms attribute contains all useful system configuration parameters for use in services. Currently, sysparms only contains the AMPS temporary directory under the &#34;tempdir&#34; key.
        config (dict): The config attribute contains all the custom configuration provided when creating the service. All config is also available in the parms attribute under the &#34;config&#34; key.
        logger (Logger): The logger attribute exposes a Logger object for logging events back to AMPS. Any messages logged using this object during the message handling or creation will appear in the corresponding session logs.
        env (string): The name of the AMPS environment in which this service is running.

    The `Service` class provides even more flexibility than the `Action` class in extending the functionality of AMPS. Unlike actions which are run and stopped, services can manage processes such as consumers/subscribers, web servers and sockets, etc, allowing the service to consume messages from and produce messages to AMPS.

    The class exposes two callback methods, `Service.initialize` and `Service.handle_message`.
    - `initialize` can be used to perform any initialization actions and start any subprocesses. Note that any subprocesses should be started in a separate thread in order to not block the main thread.
    - `handle_message` can be used to receive messages from the topic specified in the service configuration.

    The class additionally contains two methods for creating messages, `Service.send_message` and `Service.send_new`.
    `Service.send_message` should generally be used in handle_message in order to indicate that the message being created is stemming from the received message.
    Conversely, `Service.send_new` should be used to create new messages originating from an external source, such as a web server or consumer.

    Usage:
    ```
    from amps import Service
    class my_service(Service):
        def initialize(self):
            # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
            # Perform any other startup logic.

        def handle_message(self, msg, logger):
            # Maybe deliver this message to my subprocess or use it to process/transform the message.
            # Send a new message stemming from this message.
            self.send_message(
                msg, {&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;})


    ```
    &#34;&#34;&#34;

    def __init__(self, parms, sysparms, pid, env, lhandler):
        self.parms = json.loads(parms)
        self.sysparms = json.loads(sysparms)
        self.config = self.parms[&#34;config&#34;]
        self.env = env
        self.logger = Logger(service=self)
        self.__pid__ = pid
        self.__lhandler__ = lhandler
        self.initialize()

    def __receive__(self, data):
        try:
            msg = json.loads(data)
            logger = Logger(sid=msg[&#34;sid&#34;])

            logger.info(
                f&#39;Message received by Custom Service {self.parms[&#34;name&#34;]}&#39;)
            resp = self.handle_message(msg, logger)
            return (Atom(b&#39;ok&#39;), resp)
        except Exception as e:
            return (Atom(b&#39;error&#39;), str(e))

    def __response__(self, resp, id):
        global responses
        responses[id.encode(&#34;ascii&#34;)] = resp
        # f = open(id, &#34;w&#34;).write(resp)

    def __await_response__(self, id):
        global responses
        resp = responses.get(id)
        while not resp:
            resp = responses.get(id)
        return responses.pop(id)

    def __send__(self, msg):
        cast(self.__pid__, msg)

    def __send_and_receive__(self, msg):
        id = Util.get_id().encode(&#34;ascii&#34;)
        global responses
        cast(self.__pid__, (msg, id))
        resp = self.__await_response__(id)
        return json.loads(resp)

    def __log__(self, level, msg):
        cast(self.__lhandler__, (Atom(b&#39;log&#39;), (level, msg)))

    def initialize(self):
        &#34;&#34;&#34;Instance method for performing any initialization logic and starting any subprocesses.  
        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def initialize(self):
                # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
                # Perform any other startup logic.
        ```
        &#34;&#34;&#34;
        pass

    def send_message(self, msg: dict, newmsg: dict):
        &#34;&#34;&#34;Instance method for sending messages transformed by the `handle_message` callback. 
        The method accepts the original message which should be provided as is, as well as the new message with any new metadata to merge with the original message. If a &#34;data&#34; or &#34;fpath&#34; value is provided, it will overwrite the inline &#34;data&#34; or &#34;fpath&#34; on the current message. New message IDs are automatically generated and added by and retuned from this method for convenience.



        Args:
            msg (dict): The original message currently being processed in `handle_message`.
            newmsg (dict): A dictionary containing any new metadata to overwrite in the outgoing message.
        Returns:
            msgid: Message ID of the newly sent message.


        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def initialize(self):
                # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
                # Perform any other startup logic.

            def handle_message(self, msg, logger):
                # Maybe deliver this message to my subprocess or use it to process/transform the message.
                # Send a new message stemming from this message.
                self.send_message(msg, {&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;})
        ```
        &#34;&#34;&#34;
        msgid = Util.get_id()
        newmsg[&#39;parent&#39;] = msg[&#39;msgid&#39;]
        newmsg[&#39;msgid&#39;] = msgid
        if &#34;data&#34; in newmsg:
            del msg[&#34;fpath&#34;]
            newmsg[&#34;fsize&#34;] = len(newmsg[&#34;data&#34;])
        elif &#34;fpath&#34; in newmsg:
            del msg[&#34;data&#34;]
            newmsg[&#34;fsize&#34;] = os.path.getsize(newmsg[&#34;fpath&#34;])
        call(Atom(b&#39;Elixir.Amps.PyHandler&#39;), Atom(b&#39;send_message&#39;),
             [json.dumps({**msg, **newmsg}), json.dumps(self.parms), self.env])
        return msgid

    def send_new(self, newmsg: dict, action: str, response=False, timeout=15000):
        &#34;&#34;&#34;Instance method for sending new messages generated from an external source. 

        Args:
            newmsg (dict): A dictionary containing the new outgoing message to send. 
            action (str): The output map action to use when sending this message.
            response (boolean): Whether to wait for and receive all the outputs or results of the processing of new message.
            timeout (int): When response is True, this indicates how long to wait for a response from message processing. 

        Returns:
            response: If response is True, will return result of message processing, otherwise will return message ID of the newly sent message.

        The method accepts a new message with any additional metadata. If a &#34;data&#34; of &#34;fpath&#34; is provided, associated metadata is also generated. In order to get a result from the topic-based message processing of the new message, the response parameter can be passed as True.

        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def initialize(self):
                # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
                # Perform any other startup logic.

            def my_custom_function(self):
                # Any additional method in which are you generating a new message using an external source.
                self.send_new({&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;}, &#34;myaction_name&#34;)
        ```
        &#34;&#34;&#34;
        msgid = Util.get_id()
        newmsg[&#39;msgid&#39;] = msgid
        if &#34;data&#34; in newmsg:
            newmsg[&#34;fsize&#34;] = len(newmsg[&#34;data&#34;])
        else:
            newmsg[&#34;fsize&#34;] = os.path.getsize(newmsg[&#34;fpath&#34;])
        resp = self.__send_and_receive__((Atom(
            b&#39;new&#39;), json.dumps(newmsg), action, response, timeout))
        return resp

    def create_session(self, user={}):
        &#34;&#34;&#34;Instance method for authenticating and creating a session for an AMPS user.  

        Args:
            user (dict): A dictionary with a username and password key to use for authentication.

        Returns:
            success: A boolean indicating whether the operation was succesful.
            response: Either an error message when the operation fails or a dictionary with the following keys:
                access_token (str): The access token to use to authenticate the user.
                renewal_token (str): The renewal token when renewing the user&#39;s session. 
                user (dict): A dictionary containing all the user details. 
        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def my_custom_login(self, user):
                response = self.create_session(user)
                if response[&#34;success&#34;]:
                    # Handle Success
                else:
                    # Handle Failure

        ```
        &#34;&#34;&#34;
        resp = self.__send_and_receive__((Atom(
            b&#39;authenticate&#39;), json.dumps(user)))
        return resp

    def renew_session(self, renewal_token: str):
        &#34;&#34;&#34;Instance method for renewing an AMPS user&#39;s session.

        Args:
            renewal_token (str): A string containing the renewal token received when creating or renewing the session.

        Returns:
            success: A boolean indicating whether the operation was succesful.
            response: Either an error message when the operation fails or a dictionary with the following keys:
                access_token (str): The access token to use to authenticate the user.
                renewal_token (str): The renewal token when renewing the user&#39;s session. 
                user (dict): A dictionary containing all the user details. 
        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def my_renewal(self, renewal_token):
                response = self.renew_session(renewal_token)
                if response[&#34;success&#34;]:
                    # Handle Success
                else:
                    # Handle Failure

        ```
        &#34;&#34;&#34;
        resp = self.__send_and_receive__((Atom(
            b&#39;renew&#39;), renewal_token))
        return resp

    def verify(self, access_token: str):
        &#34;&#34;&#34;Instance method for verifying an AMPS user&#39;s session. 

        Args:
            access_token (str): A string containing the current access token for the user&#39;s session

        Returns:
            user: Either a dictionary with the user data on successful verification or False for failed verification. 
        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def post(self, *args):
                access_token = self.request.headers.get(&#39;Authorization&#39;)
                verified = self.verify(access_token)
                if verified:
                    # Perform Logic Here
                else:
                    # Send Error
                    self.send_error(401)

        ```
        &#34;&#34;&#34;
        resp = self.__send_and_receive__((Atom(
            b&#39;fetch&#39;), access_token))
        return resp

    def delete_session(self, access_token: str):
        &#34;&#34;&#34;Instance method for deleting an AMPS user&#39;s session. 

        Args:
            access_token (str): A string containing the current access token for the user&#39;s session

        Returns:
            success: A boolean indicating whether the operation was succesful.

        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def delete(self, *args):
                access_token = self.request.headers.get(&#39;Authorization&#39;)
                resp = self.delete_session(access_token)

        ```
        &#34;&#34;&#34;
        resp = self.__send_and_receive__((Atom(
            b&#39;delete&#39;), access_token))
        return resp

    def handle_message(self, msg: dict, logger: Logger):
        &#34;&#34;&#34;Callback method for receiving messages on the configured topic. 

        Args:
            msg (dict): The msg args contains a python dictionary of the message with all of its metadata. Message data can be accessed from the msg attribute, either using the &#34;data&#34; key for inline data, or the &#34;fpath&#34; key for a path to the file containing the data. 
            logger (Logger): A logger corresponding to the currently received message. Logging event using this object will accordingly render them in the corresponding message event sessions.
        Usage:
        ```
        from amps import Service
        class my_service(Service):
            def initialize(self):
                # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
                # Perform any other startup logic.
        ```
        &#34;&#34;&#34;
        return &#34;completed&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="amps.Service.create_session"><code class="name flex">
<span>def <span class="ident">create_session</span></span>(<span>self, user={})</span>
</code></dt>
<dd>
<div class="desc"><p>Instance method for authenticating and creating a session for an AMPS user.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary with a username and password key to use for authentication.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>success</code></dt>
<dd>A boolean indicating whether the operation was succesful.</dd>
<dt><code>response</code></dt>
<dd>Either an error message when the operation fails or a dictionary with the following keys:
access_token (str): The access token to use to authenticate the user.
renewal_token (str): The renewal token when renewing the user's session.
user (dict): A dictionary containing all the user details. </dd>
</dl>
<p>Usage:</p>
<pre><code>from amps import Service
class my_service(Service):
    def my_custom_login(self, user):
        response = self.create_session(user)
        if response[&quot;success&quot;]:
            # Handle Success
        else:
            # Handle Failure

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_session(self, user={}):
    &#34;&#34;&#34;Instance method for authenticating and creating a session for an AMPS user.  

    Args:
        user (dict): A dictionary with a username and password key to use for authentication.

    Returns:
        success: A boolean indicating whether the operation was succesful.
        response: Either an error message when the operation fails or a dictionary with the following keys:
            access_token (str): The access token to use to authenticate the user.
            renewal_token (str): The renewal token when renewing the user&#39;s session. 
            user (dict): A dictionary containing all the user details. 
    Usage:
    ```
    from amps import Service
    class my_service(Service):
        def my_custom_login(self, user):
            response = self.create_session(user)
            if response[&#34;success&#34;]:
                # Handle Success
            else:
                # Handle Failure

    ```
    &#34;&#34;&#34;
    resp = self.__send_and_receive__((Atom(
        b&#39;authenticate&#39;), json.dumps(user)))
    return resp</code></pre>
</details>
</dd>
<dt id="amps.Service.delete_session"><code class="name flex">
<span>def <span class="ident">delete_session</span></span>(<span>self, access_token:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Instance method for deleting an AMPS user's session. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>access_token</code></strong> :&ensp;<code>str</code></dt>
<dd>A string containing the current access token for the user's session</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>success</code></dt>
<dd>A boolean indicating whether the operation was succesful.</dd>
</dl>
<p>Usage:</p>
<pre><code>from amps import Service
class my_service(Service):
    def delete(self, *args):
        access_token = self.request.headers.get('Authorization')
        resp = self.delete_session(access_token)

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_session(self, access_token: str):
    &#34;&#34;&#34;Instance method for deleting an AMPS user&#39;s session. 

    Args:
        access_token (str): A string containing the current access token for the user&#39;s session

    Returns:
        success: A boolean indicating whether the operation was succesful.

    Usage:
    ```
    from amps import Service
    class my_service(Service):
        def delete(self, *args):
            access_token = self.request.headers.get(&#39;Authorization&#39;)
            resp = self.delete_session(access_token)

    ```
    &#34;&#34;&#34;
    resp = self.__send_and_receive__((Atom(
        b&#39;delete&#39;), access_token))
    return resp</code></pre>
</details>
</dd>
<dt id="amps.Service.handle_message"><code class="name flex">
<span>def <span class="ident">handle_message</span></span>(<span>self, msg:dict, logger:<a title="amps.Logger" href="#amps.Logger">Logger</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback method for receiving messages on the configured topic. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>msg</code></strong> :&ensp;<code>dict</code></dt>
<dd>The msg args contains a python dictionary of the message with all of its metadata. Message data can be accessed from the msg attribute, either using the "data" key for inline data, or the "fpath" key for a path to the file containing the data. </dd>
<dt><strong><code>logger</code></strong> :&ensp;<code><a title="amps.Logger" href="#amps.Logger">Logger</a></code></dt>
<dd>A logger corresponding to the currently received message. Logging event using this object will accordingly render them in the corresponding message event sessions.</dd>
</dl>
<p>Usage:</p>
<pre><code>from amps import Service
class my_service(Service):
    def initialize(self):
        # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
        # Perform any other startup logic.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_message(self, msg: dict, logger: Logger):
    &#34;&#34;&#34;Callback method for receiving messages on the configured topic. 

    Args:
        msg (dict): The msg args contains a python dictionary of the message with all of its metadata. Message data can be accessed from the msg attribute, either using the &#34;data&#34; key for inline data, or the &#34;fpath&#34; key for a path to the file containing the data. 
        logger (Logger): A logger corresponding to the currently received message. Logging event using this object will accordingly render them in the corresponding message event sessions.
    Usage:
    ```
    from amps import Service
    class my_service(Service):
        def initialize(self):
            # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
            # Perform any other startup logic.
    ```
    &#34;&#34;&#34;
    return &#34;completed&#34;</code></pre>
</details>
</dd>
<dt id="amps.Service.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Instance method for performing any initialization logic and starting any subprocesses.<br>
Usage:</p>
<pre><code>from amps import Service
class my_service(Service):
    def initialize(self):
        # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
        # Perform any other startup logic.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self):
    &#34;&#34;&#34;Instance method for performing any initialization logic and starting any subprocesses.  
    Usage:
    ```
    from amps import Service
    class my_service(Service):
        def initialize(self):
            # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
            # Perform any other startup logic.
    ```
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="amps.Service.renew_session"><code class="name flex">
<span>def <span class="ident">renew_session</span></span>(<span>self, renewal_token:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Instance method for renewing an AMPS user's session.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>renewal_token</code></strong> :&ensp;<code>str</code></dt>
<dd>A string containing the renewal token received when creating or renewing the session.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>success</code></dt>
<dd>A boolean indicating whether the operation was succesful.</dd>
<dt><code>response</code></dt>
<dd>Either an error message when the operation fails or a dictionary with the following keys:
access_token (str): The access token to use to authenticate the user.
renewal_token (str): The renewal token when renewing the user's session.
user (dict): A dictionary containing all the user details. </dd>
</dl>
<p>Usage:</p>
<pre><code>from amps import Service
class my_service(Service):
    def my_renewal(self, renewal_token):
        response = self.renew_session(renewal_token)
        if response[&quot;success&quot;]:
            # Handle Success
        else:
            # Handle Failure

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def renew_session(self, renewal_token: str):
    &#34;&#34;&#34;Instance method for renewing an AMPS user&#39;s session.

    Args:
        renewal_token (str): A string containing the renewal token received when creating or renewing the session.

    Returns:
        success: A boolean indicating whether the operation was succesful.
        response: Either an error message when the operation fails or a dictionary with the following keys:
            access_token (str): The access token to use to authenticate the user.
            renewal_token (str): The renewal token when renewing the user&#39;s session. 
            user (dict): A dictionary containing all the user details. 
    Usage:
    ```
    from amps import Service
    class my_service(Service):
        def my_renewal(self, renewal_token):
            response = self.renew_session(renewal_token)
            if response[&#34;success&#34;]:
                # Handle Success
            else:
                # Handle Failure

    ```
    &#34;&#34;&#34;
    resp = self.__send_and_receive__((Atom(
        b&#39;renew&#39;), renewal_token))
    return resp</code></pre>
</details>
</dd>
<dt id="amps.Service.send_message"><code class="name flex">
<span>def <span class="ident">send_message</span></span>(<span>self, msg:dict, newmsg:dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Instance method for sending messages transformed by the <code>handle_message</code> callback.
The method accepts the original message which should be provided as is, as well as the new message with any new metadata to merge with the original message. If a "data" or "fpath" value is provided, it will overwrite the inline "data" or "fpath" on the current message. New message IDs are automatically generated and added by and retuned from this method for convenience.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>msg</code></strong> :&ensp;<code>dict</code></dt>
<dd>The original message currently being processed in <code>handle_message</code>.</dd>
<dt><strong><code>newmsg</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing any new metadata to overwrite in the outgoing message.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>msgid</code></dt>
<dd>Message ID of the newly sent message.</dd>
</dl>
<p>Usage:</p>
<pre><code>from amps import Service
class my_service(Service):
    def initialize(self):
        # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
        # Perform any other startup logic.

    def handle_message(self, msg, logger):
        # Maybe deliver this message to my subprocess or use it to process/transform the message.
        # Send a new message stemming from this message.
        self.send_message(msg, {&quot;data&quot;: &quot;New Message Data Here&quot;, &quot;my_custom&quot;: &quot;metadata&quot;})
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_message(self, msg: dict, newmsg: dict):
    &#34;&#34;&#34;Instance method for sending messages transformed by the `handle_message` callback. 
    The method accepts the original message which should be provided as is, as well as the new message with any new metadata to merge with the original message. If a &#34;data&#34; or &#34;fpath&#34; value is provided, it will overwrite the inline &#34;data&#34; or &#34;fpath&#34; on the current message. New message IDs are automatically generated and added by and retuned from this method for convenience.



    Args:
        msg (dict): The original message currently being processed in `handle_message`.
        newmsg (dict): A dictionary containing any new metadata to overwrite in the outgoing message.
    Returns:
        msgid: Message ID of the newly sent message.


    Usage:
    ```
    from amps import Service
    class my_service(Service):
        def initialize(self):
            # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
            # Perform any other startup logic.

        def handle_message(self, msg, logger):
            # Maybe deliver this message to my subprocess or use it to process/transform the message.
            # Send a new message stemming from this message.
            self.send_message(msg, {&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;})
    ```
    &#34;&#34;&#34;
    msgid = Util.get_id()
    newmsg[&#39;parent&#39;] = msg[&#39;msgid&#39;]
    newmsg[&#39;msgid&#39;] = msgid
    if &#34;data&#34; in newmsg:
        del msg[&#34;fpath&#34;]
        newmsg[&#34;fsize&#34;] = len(newmsg[&#34;data&#34;])
    elif &#34;fpath&#34; in newmsg:
        del msg[&#34;data&#34;]
        newmsg[&#34;fsize&#34;] = os.path.getsize(newmsg[&#34;fpath&#34;])
    call(Atom(b&#39;Elixir.Amps.PyHandler&#39;), Atom(b&#39;send_message&#39;),
         [json.dumps({**msg, **newmsg}), json.dumps(self.parms), self.env])
    return msgid</code></pre>
</details>
</dd>
<dt id="amps.Service.send_new"><code class="name flex">
<span>def <span class="ident">send_new</span></span>(<span>self, newmsg:dict, action:str, response=False, timeout=15000)</span>
</code></dt>
<dd>
<div class="desc"><p>Instance method for sending new messages generated from an external source. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>newmsg</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing the new outgoing message to send. </dd>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>The output map action to use when sending this message.</dd>
<dt><strong><code>response</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether to wait for and receive all the outputs or results of the processing of new message.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>When response is True, this indicates how long to wait for a response from message processing. </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>response</code></dt>
<dd>If response is True, will return result of message processing, otherwise will return message ID of the newly sent message.</dd>
</dl>
<p>The method accepts a new message with any additional metadata. If a "data" of "fpath" is provided, associated metadata is also generated. In order to get a result from the topic-based message processing of the new message, the response parameter can be passed as True.</p>
<p>Usage:</p>
<pre><code>from amps import Service
class my_service(Service):
    def initialize(self):
        # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
        # Perform any other startup logic.

    def my_custom_function(self):
        # Any additional method in which are you generating a new message using an external source.
        self.send_new({&quot;data&quot;: &quot;New Message Data Here&quot;, &quot;my_custom&quot;: &quot;metadata&quot;}, &quot;myaction_name&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_new(self, newmsg: dict, action: str, response=False, timeout=15000):
    &#34;&#34;&#34;Instance method for sending new messages generated from an external source. 

    Args:
        newmsg (dict): A dictionary containing the new outgoing message to send. 
        action (str): The output map action to use when sending this message.
        response (boolean): Whether to wait for and receive all the outputs or results of the processing of new message.
        timeout (int): When response is True, this indicates how long to wait for a response from message processing. 

    Returns:
        response: If response is True, will return result of message processing, otherwise will return message ID of the newly sent message.

    The method accepts a new message with any additional metadata. If a &#34;data&#34; of &#34;fpath&#34; is provided, associated metadata is also generated. In order to get a result from the topic-based message processing of the new message, the response parameter can be passed as True.

    Usage:
    ```
    from amps import Service
    class my_service(Service):
        def initialize(self):
            # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
            # Perform any other startup logic.

        def my_custom_function(self):
            # Any additional method in which are you generating a new message using an external source.
            self.send_new({&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;}, &#34;myaction_name&#34;)
    ```
    &#34;&#34;&#34;
    msgid = Util.get_id()
    newmsg[&#39;msgid&#39;] = msgid
    if &#34;data&#34; in newmsg:
        newmsg[&#34;fsize&#34;] = len(newmsg[&#34;data&#34;])
    else:
        newmsg[&#34;fsize&#34;] = os.path.getsize(newmsg[&#34;fpath&#34;])
    resp = self.__send_and_receive__((Atom(
        b&#39;new&#39;), json.dumps(newmsg), action, response, timeout))
    return resp</code></pre>
</details>
</dd>
<dt id="amps.Service.verify"><code class="name flex">
<span>def <span class="ident">verify</span></span>(<span>self, access_token:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Instance method for verifying an AMPS user's session. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>access_token</code></strong> :&ensp;<code>str</code></dt>
<dd>A string containing the current access token for the user's session</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>user</code></dt>
<dd>Either a dictionary with the user data on successful verification or False for failed verification. </dd>
</dl>
<p>Usage:</p>
<pre><code>from amps import Service
class my_service(Service):
    def post(self, *args):
        access_token = self.request.headers.get('Authorization')
        verified = self.verify(access_token)
        if verified:
            # Perform Logic Here
        else:
            # Send Error
            self.send_error(401)

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify(self, access_token: str):
    &#34;&#34;&#34;Instance method for verifying an AMPS user&#39;s session. 

    Args:
        access_token (str): A string containing the current access token for the user&#39;s session

    Returns:
        user: Either a dictionary with the user data on successful verification or False for failed verification. 
    Usage:
    ```
    from amps import Service
    class my_service(Service):
        def post(self, *args):
            access_token = self.request.headers.get(&#39;Authorization&#39;)
            verified = self.verify(access_token)
            if verified:
                # Perform Logic Here
            else:
                # Send Error
                self.send_error(401)

    ```
    &#34;&#34;&#34;
    resp = self.__send_and_receive__((Atom(
        b&#39;fetch&#39;), access_token))
    return resp</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="amps.Users"><code class="flex name class">
<span>class <span class="ident">Users</span></span>
<span>(</span><span>env)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Users:
    def __init__(self, env):
        self.env = env

    def find(self, env, clauses={}, opts={}):
        coll = bytes(collection, &#34;utf-8&#34;)
        collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
            b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
        clauses = Map(clauses)
        opts = Map(opts)
        result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                      Atom(b&#39;find&#39;), [collection, clauses, opts])
        return Util.unravel_erlport_object(result)

    def find_one(self, env, clauses={}, opts={}):
        coll = bytes(collection, &#34;utf-8&#34;)
        collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
            b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
        clauses = Map(clauses)
        opts = Map(opts)
        result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                      Atom(b&#39;find_one&#39;), [collection, clauses, opts])
        return Util.unravel_erlport_object(result)

    def create(self, user):
        user = Map(user)
        result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                      Atom(b&#39;create&#39;), [user, self.env])
        return Util.unravel_erlport_object(result)

    def update(self, id, body):
        user = Map(body)
        result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                      Atom(b&#39;update&#39;), [id, user, self.env])
        return Util.unravel_erlport_object(result)

    def delete(self, id):
        result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                      Atom(b&#39;delete&#39;), [id, self.env])
        return Util.unravel_erlport_object(result)

    def create_session(self, user):
        user = Map(user)
        result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                      Atom(b&#39;create_session&#39;), [user, self.env])
        return Util.unravel_erlport_object(result)

    def authenticate(self, access_token):
        result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                      Atom(b&#39;authenticate&#39;), [access_token, self.env])
        return Util.unravel_erlport_object(result)

    def renew_session(self, renewal_token):
        result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                      Atom(b&#39;renew_session&#39;), [renewal_token, self.env])
        return Util.unravel_erlport_object(result)

    def delete_session(self, access_token):
        result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                      Atom(b&#39;delete_session&#39;), [access_token, self.env])
        return Util.unravel_erlport_object(result)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="amps.Users.authenticate"><code class="name flex">
<span>def <span class="ident">authenticate</span></span>(<span>self, access_token)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authenticate(self, access_token):
    result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                  Atom(b&#39;authenticate&#39;), [access_token, self.env])
    return Util.unravel_erlport_object(result)</code></pre>
</details>
</dd>
<dt id="amps.Users.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, user)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, user):
    user = Map(user)
    result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                  Atom(b&#39;create&#39;), [user, self.env])
    return Util.unravel_erlport_object(result)</code></pre>
</details>
</dd>
<dt id="amps.Users.create_session"><code class="name flex">
<span>def <span class="ident">create_session</span></span>(<span>self, user)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_session(self, user):
    user = Map(user)
    result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                  Atom(b&#39;create_session&#39;), [user, self.env])
    return Util.unravel_erlport_object(result)</code></pre>
</details>
</dd>
<dt id="amps.Users.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, id):
    result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                  Atom(b&#39;delete&#39;), [id, self.env])
    return Util.unravel_erlport_object(result)</code></pre>
</details>
</dd>
<dt id="amps.Users.delete_session"><code class="name flex">
<span>def <span class="ident">delete_session</span></span>(<span>self, access_token)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_session(self, access_token):
    result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                  Atom(b&#39;delete_session&#39;), [access_token, self.env])
    return Util.unravel_erlport_object(result)</code></pre>
</details>
</dd>
<dt id="amps.Users.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, env, clauses={}, opts={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, env, clauses={}, opts={}):
    coll = bytes(collection, &#34;utf-8&#34;)
    collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
        b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
    clauses = Map(clauses)
    opts = Map(opts)
    result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                  Atom(b&#39;find&#39;), [collection, clauses, opts])
    return Util.unravel_erlport_object(result)</code></pre>
</details>
</dd>
<dt id="amps.Users.find_one"><code class="name flex">
<span>def <span class="ident">find_one</span></span>(<span>self, env, clauses={}, opts={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_one(self, env, clauses={}, opts={}):
    coll = bytes(collection, &#34;utf-8&#34;)
    collection = call(Atom(b&#39;Elixir.AmpsUtil&#39;), Atom(
        b&#39;index&#39;), [bytes(self.env, &#34;utf-8&#34;), coll])
    clauses = Map(clauses)
    opts = Map(opts)
    result = call(Atom(b&#39;Elixir.Amps.PyService&#39;),
                  Atom(b&#39;find_one&#39;), [collection, clauses, opts])
    return Util.unravel_erlport_object(result)</code></pre>
</details>
</dd>
<dt id="amps.Users.renew_session"><code class="name flex">
<span>def <span class="ident">renew_session</span></span>(<span>self, renewal_token)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def renew_session(self, renewal_token):
    result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                  Atom(b&#39;renew_session&#39;), [renewal_token, self.env])
    return Util.unravel_erlport_object(result)</code></pre>
</details>
</dd>
<dt id="amps.Users.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, id, body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, id, body):
    user = Map(body)
    result = call(Atom(b&#39;Elixir.Amps.PyService.Users&#39;),
                  Atom(b&#39;update&#39;), [id, user, self.env])
    return Util.unravel_erlport_object(result)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="amps.Util"><code class="flex name class">
<span>class <span class="ident">Util</span></span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="amps.Util" href="#amps.Util">Util</a></code> class provides utility methods that may be useful during action and service execution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Util:
    &#34;&#34;&#34;The `Util` class provides utility methods that may be useful during action and service execution.


    &#34;&#34;&#34;
    def get_id():
        &#34;&#34;&#34;Utility method that returns a unique ID in the format used by AMPS.
        &#34;&#34;&#34;
        return uuid.UUID(str(uuid.uuid4())).hex

    @staticmethod
    def unravel_erlport_object(result):
        if isinstance(result, List):
            return [Util.unravel_erlport_object(x) for x in result]
        elif isinstance(result, Map):
            return {k.decode(): Util.unravel_erlport_object(v) for k, v in result.items()}
        elif isinstance(result, Atom):
            return result.decode()
        elif isinstance(result, bytes):
            return result.decode()
        else:
            return result</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="amps.Util.unravel_erlport_object"><code class="name flex">
<span>def <span class="ident">unravel_erlport_object</span></span>(<span>result)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def unravel_erlport_object(result):
    if isinstance(result, List):
        return [Util.unravel_erlport_object(x) for x in result]
    elif isinstance(result, Map):
        return {k.decode(): Util.unravel_erlport_object(v) for k, v in result.items()}
    elif isinstance(result, Atom):
        return result.decode()
    elif isinstance(result, bytes):
        return result.decode()
    else:
        return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="amps.Util.get_id"><code class="name flex">
<span>def <span class="ident">get_id</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Utility method that returns a unique ID in the format used by AMPS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id():
    &#34;&#34;&#34;Utility method that returns a unique ID in the format used by AMPS.
    &#34;&#34;&#34;
    return uuid.UUID(str(uuid.uuid4())).hex</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="amps-py Home" href="https://mft-labs.github.io/amps-py/">
<img src="black.png" alt="">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="amps.Action" href="#amps.Action">Action</a></code></h4>
<ul class="two-column">
<li><code><a title="amps.Action.action" href="#amps.Action.action">action</a></code></li>
<li><code><a title="amps.Action.get_data" href="#amps.Action.get_data">get_data</a></code></li>
<li><code><a title="amps.Action.send_async" href="#amps.Action.send_async">send_async</a></code></li>
<li><code><a title="amps.Action.send_data" href="#amps.Action.send_data">send_data</a></code></li>
<li><code><a title="amps.Action.send_error" href="#amps.Action.send_error">send_error</a></code></li>
<li><code><a title="amps.Action.send_file" href="#amps.Action.send_file">send_file</a></code></li>
<li><code><a title="amps.Action.send_status" href="#amps.Action.send_status">send_status</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="amps.DB" href="#amps.DB">DB</a></code></h4>
<ul class="">
<li><code><a title="amps.DB.create" href="#amps.DB.create">create</a></code></li>
<li><code><a title="amps.DB.delete" href="#amps.DB.delete">delete</a></code></li>
<li><code><a title="amps.DB.find" href="#amps.DB.find">find</a></code></li>
<li><code><a title="amps.DB.find_one" href="#amps.DB.find_one">find_one</a></code></li>
<li><code><a title="amps.DB.update" href="#amps.DB.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="amps.Endpoint" href="#amps.Endpoint">Endpoint</a></code></h4>
<ul class="">
<li><code><a title="amps.Endpoint.send_resp_data" href="#amps.Endpoint.send_resp_data">send_resp_data</a></code></li>
<li><code><a title="amps.Endpoint.send_resp_file" href="#amps.Endpoint.send_resp_file">send_resp_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="amps.Logger" href="#amps.Logger">Logger</a></code></h4>
<ul class="">
<li><code><a title="amps.Logger.debug" href="#amps.Logger.debug">debug</a></code></li>
<li><code><a title="amps.Logger.error" href="#amps.Logger.error">error</a></code></li>
<li><code><a title="amps.Logger.info" href="#amps.Logger.info">info</a></code></li>
<li><code><a title="amps.Logger.log" href="#amps.Logger.log">log</a></code></li>
<li><code><a title="amps.Logger.warning" href="#amps.Logger.warning">warning</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="amps.Service" href="#amps.Service">Service</a></code></h4>
<ul class="two-column">
<li><code><a title="amps.Service.create_session" href="#amps.Service.create_session">create_session</a></code></li>
<li><code><a title="amps.Service.delete_session" href="#amps.Service.delete_session">delete_session</a></code></li>
<li><code><a title="amps.Service.handle_message" href="#amps.Service.handle_message">handle_message</a></code></li>
<li><code><a title="amps.Service.initialize" href="#amps.Service.initialize">initialize</a></code></li>
<li><code><a title="amps.Service.renew_session" href="#amps.Service.renew_session">renew_session</a></code></li>
<li><code><a title="amps.Service.send_message" href="#amps.Service.send_message">send_message</a></code></li>
<li><code><a title="amps.Service.send_new" href="#amps.Service.send_new">send_new</a></code></li>
<li><code><a title="amps.Service.verify" href="#amps.Service.verify">verify</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="amps.Users" href="#amps.Users">Users</a></code></h4>
<ul class="two-column">
<li><code><a title="amps.Users.authenticate" href="#amps.Users.authenticate">authenticate</a></code></li>
<li><code><a title="amps.Users.create" href="#amps.Users.create">create</a></code></li>
<li><code><a title="amps.Users.create_session" href="#amps.Users.create_session">create_session</a></code></li>
<li><code><a title="amps.Users.delete" href="#amps.Users.delete">delete</a></code></li>
<li><code><a title="amps.Users.delete_session" href="#amps.Users.delete_session">delete_session</a></code></li>
<li><code><a title="amps.Users.find" href="#amps.Users.find">find</a></code></li>
<li><code><a title="amps.Users.find_one" href="#amps.Users.find_one">find_one</a></code></li>
<li><code><a title="amps.Users.renew_session" href="#amps.Users.renew_session">renew_session</a></code></li>
<li><code><a title="amps.Users.update" href="#amps.Users.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="amps.Util" href="#amps.Util">Util</a></code></h4>
<ul class="">
<li><code><a title="amps.Util.get_id" href="#amps.Util.get_id">get_id</a></code></li>
<li><code><a title="amps.Util.unravel_erlport_object" href="#amps.Util.unravel_erlport_object">unravel_erlport_object</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>