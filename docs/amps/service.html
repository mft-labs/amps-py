<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>amps.service API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>amps.service</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># from erlport.erlterms import Atom
# from erlport.erlang import cast, call
import os
import json
from .logger import Logger
from .util import Util


class Service:
    &#39;&#39;&#39;The `Service` class from AMPS provides a base class for custom python services that can be managed by AMPS, and act as both consumers of messages and producers of new messages.

    The following attributes are available on the `Service` instance.

    - parms: The parms attribute contains all the parameters of the configured service.
    - sysparms: The sysparms attribute contains all useful system configuration parameters for use in services. Currently, sysparms only contains the AMPS temporary directory under the &#34;tempdir&#34; key. 
    - config: The config attribute contains all the custom configuration provided when creating the service. All config is also available in the parms attribute under the &#34;config&#34; key. 
    - logger: The logger attribute exposes a Logger object for logging events back to AMPS. Any messages logged using this object during the message handling or creation will appear in the corresponding session logs. 
    - env: The name of the AMPS environment in which this service is running.

    The `Service` class provides even more flexibility than the `Action` class in extending the functionality of AMPS. Unlike actions which are run and stopped, services can manage processes such as consumers/subscribers, web servers and sockets, etc, allowing the service to consume messages from and produce messages to AMPS. 

    The class exposes two callback methods, `initialize` and `handle_message`.
    - `initialize` can be used to perform any initialization actions and start any subprocesses. Note that any subprocesses should be started in a separate thread in order to not block the main thread. 
    - `handle_message` can be used to receive messages from the topic specified in the service configuration.

    The class additionally contains two methods for creating messages, `send_message` and `send_new`.
    `send_message` should generally be used in handle_message in order to indicate that the message being created is stemming from the received message.
    Conversely, `send_new` should be used to create new messages originating from an external source, such as a web server or consumer.

    #### Usage:
    ```
    from amps import Service
    def my_service(Service):
        def initialize(self):
            # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
            # Perform any other startup logic.

        def handle_message(self, msg, logger):
            # Maybe deliver this message to my subprocess or use it to process/transform the message.
            # Send a new message stemming from this message.
            self.send_message(msg, {&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;})


    ```
    &#39;&#39;&#39;

    def __init__(self, parms, sysparms, pid, env, handler, lhandler):
        self.parms = json.loads(parms)
        self.sysparms = json.loads(sysparms)
        self.config = self.parms[&#34;config&#34;]
        self.env = env
        self.logger = Logger(service=self)
        self.__pid__ = pid
        self.__handler__ = handler
        self.__lhandler__ = lhandler
        self.initialize()

    def __receive__(self, data):
        try:
            msg = json.loads(data)
            logger = Logger(sid=msg[&#34;sid&#34;])

            logger.info(
                f&#39;Message received by Custom Service {self.parms[&#34;name&#34;]}&#39;)
            resp = self.handle_message(msg, logger)
            return (Atom(b&#39;ok&#39;), resp)
        except Exception as e:
            return (Atom(b&#39;error&#39;), str(e))

    def __send__(self, msg):
        cast(self.__pid__, msg)

    def __log__(self, level, msg):
        cast(self.__lhandler__, (Atom(b&#39;log&#39;), (level, msg)))

    def initialize(self):
        pass

    def send_message(self, msg: dict, newmsg: dict):
        &#39;&#39;&#39;Instance method for sending messages transformed by the `handle_message` callback. 

        :param msg: The original message currently being processed in `handle_message`.
        :param newmsg: Any new metadata to overwrite in the outgoing message. 

        The method accepts the original message which should be provided as is, as well as the new message with any new metadata to merge with the original message. If a &#34;data&#34; or &#34;fpath&#34; value is provided, it will overwrite the inline &#34;data&#34; or &#34;fpath&#34; on the current message. New message IDs are automatically generated and added by and retuned from this method for convenience.

        #### Usage:
        ```
        from amps import Service
        def my_service(Service):
            def initialize(self):
                # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
                # Perform any other startup logic.

            def handle_message(self, msg, logger):
                # Maybe deliver this message to my subprocess or use it to process/transform the message.
                # Send a new message stemming from this message.
                self.send_message(msg, {&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;})
        ```
        &#39;&#39;&#39;
        msgid = Util.get_id()
        newmsg[&#39;parent&#39;] = msg[&#39;msgid&#39;]
        newmsg[&#39;msgid&#39;] = msgid
        if &#34;data&#34; in newmsg:
            del msg[&#34;fpath&#34;]
            newmsg[&#34;fsize&#34;] = len(newmsg[&#34;data&#34;])
        elif &#34;fpath&#34; in newmsg:
            del msg[&#34;data&#34;]
            newmsg[&#34;fsize&#34;] = os.path.getsize(newmsg[&#34;fpath&#34;])
        call(Atom(b&#39;Elixir.Amps.PyProcess&#39;), Atom(b&#39;send_message&#39;),
             [json.dumps({**msg, **newmsg}), json.dumps(self.parms)])
        return msgid

    def send_new(self, newmsg: dict):
        &#39;&#39;&#39;Instance method for sending new messages generated from an external source. 

        :param newmsg: The new outgoing message to send. 

        The method accepts a new message with any additional metadata. If a &#34;data&#34; of &#34;fpath&#34; is provided, associated metadata is also generated. A message ID is automatically assigned to the message and returned from the method.

        #### Usage:
        ```
        from amps import Service
        def my_service(Service):
            def initialize(self):
                # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
                # Perform any other startup logic.

            def my_custom_function(self):
                # Any additional method in which are you generating a new message using an external source.
                self.send_new({&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;})
        ```
        &#39;&#39;&#39;
        msgid = Util.get_id()
        newmsg[&#39;msgid&#39;] = msgid
        if &#34;data&#34; in newmsg:
            newmsg[&#34;fsize&#34;] = len(newmsg[&#34;data&#34;])
        else:
            newmsg[&#34;fsize&#34;] = os.path.getsize(newmsg[&#34;fpath&#34;])
        print(newmsg)
        print(call)
        cast(self.__handler__, (Atom(b&#39;new&#39;), json.dumps(newmsg)))
        return msgid

    def handle_message(self, data):
        return &#34;completed&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="amps.service.Service"><code class="flex name class">
<span>class <span class="ident">Service</span></span>
<span>(</span><span>parms, sysparms, pid, env, handler, lhandler)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="amps.service.Service" href="#amps.service.Service">Service</a></code> class from AMPS provides a base class for custom python services that can be managed by AMPS, and act as both consumers of messages and producers of new messages.</p>
<p>The following attributes are available on the <code><a title="amps.service.Service" href="#amps.service.Service">Service</a></code> instance.</p>
<ul>
<li>parms: The parms attribute contains all the parameters of the configured service.</li>
<li>sysparms: The sysparms attribute contains all useful system configuration parameters for use in services. Currently, sysparms only contains the AMPS temporary directory under the "tempdir" key. </li>
<li>config: The config attribute contains all the custom configuration provided when creating the service. All config is also available in the parms attribute under the "config" key. </li>
<li>logger: The logger attribute exposes a Logger object for logging events back to AMPS. Any messages logged using this object during the message handling or creation will appear in the corresponding session logs. </li>
<li>env: The name of the AMPS environment in which this service is running.</li>
</ul>
<p>The <code><a title="amps.service.Service" href="#amps.service.Service">Service</a></code> class provides even more flexibility than the <code>Action</code> class in extending the functionality of AMPS. Unlike actions which are run and stopped, services can manage processes such as consumers/subscribers, web servers and sockets, etc, allowing the service to consume messages from and produce messages to AMPS. </p>
<p>The class exposes two callback methods, <code>initialize</code> and <code>handle_message</code>.
- <code>initialize</code> can be used to perform any initialization actions and start any subprocesses. Note that any subprocesses should be started in a separate thread in order to not block the main thread.
- <code>handle_message</code> can be used to receive messages from the topic specified in the service configuration.</p>
<p>The class additionally contains two methods for creating messages, <code>send_message</code> and <code>send_new</code>.
<code>send_message</code> should generally be used in handle_message in order to indicate that the message being created is stemming from the received message.
Conversely, <code>send_new</code> should be used to create new messages originating from an external source, such as a web server or consumer.</p>
<h4 id="usage">Usage:</h4>
<pre><code>from amps import Service
def my_service(Service):
    def initialize(self):
        # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
        # Perform any other startup logic.

    def handle_message(self, msg, logger):
        # Maybe deliver this message to my subprocess or use it to process/transform the message.
        # Send a new message stemming from this message.
        self.send_message(msg, {&quot;data&quot;: &quot;New Message Data Here&quot;, &quot;my_custom&quot;: &quot;metadata&quot;})


</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Service:
    &#39;&#39;&#39;The `Service` class from AMPS provides a base class for custom python services that can be managed by AMPS, and act as both consumers of messages and producers of new messages.

    The following attributes are available on the `Service` instance.

    - parms: The parms attribute contains all the parameters of the configured service.
    - sysparms: The sysparms attribute contains all useful system configuration parameters for use in services. Currently, sysparms only contains the AMPS temporary directory under the &#34;tempdir&#34; key. 
    - config: The config attribute contains all the custom configuration provided when creating the service. All config is also available in the parms attribute under the &#34;config&#34; key. 
    - logger: The logger attribute exposes a Logger object for logging events back to AMPS. Any messages logged using this object during the message handling or creation will appear in the corresponding session logs. 
    - env: The name of the AMPS environment in which this service is running.

    The `Service` class provides even more flexibility than the `Action` class in extending the functionality of AMPS. Unlike actions which are run and stopped, services can manage processes such as consumers/subscribers, web servers and sockets, etc, allowing the service to consume messages from and produce messages to AMPS. 

    The class exposes two callback methods, `initialize` and `handle_message`.
    - `initialize` can be used to perform any initialization actions and start any subprocesses. Note that any subprocesses should be started in a separate thread in order to not block the main thread. 
    - `handle_message` can be used to receive messages from the topic specified in the service configuration.

    The class additionally contains two methods for creating messages, `send_message` and `send_new`.
    `send_message` should generally be used in handle_message in order to indicate that the message being created is stemming from the received message.
    Conversely, `send_new` should be used to create new messages originating from an external source, such as a web server or consumer.

    #### Usage:
    ```
    from amps import Service
    def my_service(Service):
        def initialize(self):
            # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
            # Perform any other startup logic.

        def handle_message(self, msg, logger):
            # Maybe deliver this message to my subprocess or use it to process/transform the message.
            # Send a new message stemming from this message.
            self.send_message(msg, {&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;})


    ```
    &#39;&#39;&#39;

    def __init__(self, parms, sysparms, pid, env, handler, lhandler):
        self.parms = json.loads(parms)
        self.sysparms = json.loads(sysparms)
        self.config = self.parms[&#34;config&#34;]
        self.env = env
        self.logger = Logger(service=self)
        self.__pid__ = pid
        self.__handler__ = handler
        self.__lhandler__ = lhandler
        self.initialize()

    def __receive__(self, data):
        try:
            msg = json.loads(data)
            logger = Logger(sid=msg[&#34;sid&#34;])

            logger.info(
                f&#39;Message received by Custom Service {self.parms[&#34;name&#34;]}&#39;)
            resp = self.handle_message(msg, logger)
            return (Atom(b&#39;ok&#39;), resp)
        except Exception as e:
            return (Atom(b&#39;error&#39;), str(e))

    def __send__(self, msg):
        cast(self.__pid__, msg)

    def __log__(self, level, msg):
        cast(self.__lhandler__, (Atom(b&#39;log&#39;), (level, msg)))

    def initialize(self):
        pass

    def send_message(self, msg: dict, newmsg: dict):
        &#39;&#39;&#39;Instance method for sending messages transformed by the `handle_message` callback. 

        :param msg: The original message currently being processed in `handle_message`.
        :param newmsg: Any new metadata to overwrite in the outgoing message. 

        The method accepts the original message which should be provided as is, as well as the new message with any new metadata to merge with the original message. If a &#34;data&#34; or &#34;fpath&#34; value is provided, it will overwrite the inline &#34;data&#34; or &#34;fpath&#34; on the current message. New message IDs are automatically generated and added by and retuned from this method for convenience.

        #### Usage:
        ```
        from amps import Service
        def my_service(Service):
            def initialize(self):
                # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
                # Perform any other startup logic.

            def handle_message(self, msg, logger):
                # Maybe deliver this message to my subprocess or use it to process/transform the message.
                # Send a new message stemming from this message.
                self.send_message(msg, {&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;})
        ```
        &#39;&#39;&#39;
        msgid = Util.get_id()
        newmsg[&#39;parent&#39;] = msg[&#39;msgid&#39;]
        newmsg[&#39;msgid&#39;] = msgid
        if &#34;data&#34; in newmsg:
            del msg[&#34;fpath&#34;]
            newmsg[&#34;fsize&#34;] = len(newmsg[&#34;data&#34;])
        elif &#34;fpath&#34; in newmsg:
            del msg[&#34;data&#34;]
            newmsg[&#34;fsize&#34;] = os.path.getsize(newmsg[&#34;fpath&#34;])
        call(Atom(b&#39;Elixir.Amps.PyProcess&#39;), Atom(b&#39;send_message&#39;),
             [json.dumps({**msg, **newmsg}), json.dumps(self.parms)])
        return msgid

    def send_new(self, newmsg: dict):
        &#39;&#39;&#39;Instance method for sending new messages generated from an external source. 

        :param newmsg: The new outgoing message to send. 

        The method accepts a new message with any additional metadata. If a &#34;data&#34; of &#34;fpath&#34; is provided, associated metadata is also generated. A message ID is automatically assigned to the message and returned from the method.

        #### Usage:
        ```
        from amps import Service
        def my_service(Service):
            def initialize(self):
                # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
                # Perform any other startup logic.

            def my_custom_function(self):
                # Any additional method in which are you generating a new message using an external source.
                self.send_new({&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;})
        ```
        &#39;&#39;&#39;
        msgid = Util.get_id()
        newmsg[&#39;msgid&#39;] = msgid
        if &#34;data&#34; in newmsg:
            newmsg[&#34;fsize&#34;] = len(newmsg[&#34;data&#34;])
        else:
            newmsg[&#34;fsize&#34;] = os.path.getsize(newmsg[&#34;fpath&#34;])
        print(newmsg)
        print(call)
        cast(self.__handler__, (Atom(b&#39;new&#39;), json.dumps(newmsg)))
        return msgid

    def handle_message(self, data):
        return &#34;completed&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="amps.service.Service.handle_message"><code class="name flex">
<span>def <span class="ident">handle_message</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_message(self, data):
    return &#34;completed&#34;</code></pre>
</details>
</dd>
<dt id="amps.service.Service.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self):
    pass</code></pre>
</details>
</dd>
<dt id="amps.service.Service.send_message"><code class="name flex">
<span>def <span class="ident">send_message</span></span>(<span>self, msg: dict, newmsg: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Instance method for sending messages transformed by the <code>handle_message</code> callback. </p>
<p>:param msg: The original message currently being processed in <code>handle_message</code>.
:param newmsg: Any new metadata to overwrite in the outgoing message. </p>
<p>The method accepts the original message which should be provided as is, as well as the new message with any new metadata to merge with the original message. If a "data" or "fpath" value is provided, it will overwrite the inline "data" or "fpath" on the current message. New message IDs are automatically generated and added by and retuned from this method for convenience.</p>
<h4 id="usage">Usage:</h4>
<pre><code>from amps import Service
def my_service(Service):
    def initialize(self):
        # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
        # Perform any other startup logic.

    def handle_message(self, msg, logger):
        # Maybe deliver this message to my subprocess or use it to process/transform the message.
        # Send a new message stemming from this message.
        self.send_message(msg, {&quot;data&quot;: &quot;New Message Data Here&quot;, &quot;my_custom&quot;: &quot;metadata&quot;})
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_message(self, msg: dict, newmsg: dict):
    &#39;&#39;&#39;Instance method for sending messages transformed by the `handle_message` callback. 

    :param msg: The original message currently being processed in `handle_message`.
    :param newmsg: Any new metadata to overwrite in the outgoing message. 

    The method accepts the original message which should be provided as is, as well as the new message with any new metadata to merge with the original message. If a &#34;data&#34; or &#34;fpath&#34; value is provided, it will overwrite the inline &#34;data&#34; or &#34;fpath&#34; on the current message. New message IDs are automatically generated and added by and retuned from this method for convenience.

    #### Usage:
    ```
    from amps import Service
    def my_service(Service):
        def initialize(self):
            # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
            # Perform any other startup logic.

        def handle_message(self, msg, logger):
            # Maybe deliver this message to my subprocess or use it to process/transform the message.
            # Send a new message stemming from this message.
            self.send_message(msg, {&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;})
    ```
    &#39;&#39;&#39;
    msgid = Util.get_id()
    newmsg[&#39;parent&#39;] = msg[&#39;msgid&#39;]
    newmsg[&#39;msgid&#39;] = msgid
    if &#34;data&#34; in newmsg:
        del msg[&#34;fpath&#34;]
        newmsg[&#34;fsize&#34;] = len(newmsg[&#34;data&#34;])
    elif &#34;fpath&#34; in newmsg:
        del msg[&#34;data&#34;]
        newmsg[&#34;fsize&#34;] = os.path.getsize(newmsg[&#34;fpath&#34;])
    call(Atom(b&#39;Elixir.Amps.PyProcess&#39;), Atom(b&#39;send_message&#39;),
         [json.dumps({**msg, **newmsg}), json.dumps(self.parms)])
    return msgid</code></pre>
</details>
</dd>
<dt id="amps.service.Service.send_new"><code class="name flex">
<span>def <span class="ident">send_new</span></span>(<span>self, newmsg: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Instance method for sending new messages generated from an external source. </p>
<p>:param newmsg: The new outgoing message to send. </p>
<p>The method accepts a new message with any additional metadata. If a "data" of "fpath" is provided, associated metadata is also generated. A message ID is automatically assigned to the message and returned from the method.</p>
<h4 id="usage">Usage:</h4>
<pre><code>from amps import Service
def my_service(Service):
    def initialize(self):
        # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
        # Perform any other startup logic.

    def my_custom_function(self):
        # Any additional method in which are you generating a new message using an external source.
        self.send_new({&quot;data&quot;: &quot;New Message Data Here&quot;, &quot;my_custom&quot;: &quot;metadata&quot;})
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_new(self, newmsg: dict):
    &#39;&#39;&#39;Instance method for sending new messages generated from an external source. 

    :param newmsg: The new outgoing message to send. 

    The method accepts a new message with any additional metadata. If a &#34;data&#34; of &#34;fpath&#34; is provided, associated metadata is also generated. A message ID is automatically assigned to the message and returned from the method.

    #### Usage:
    ```
    from amps import Service
    def my_service(Service):
        def initialize(self):
            # Start my subprocess here, potentially passing service reference to subprocess so that it can leverage `send_new`.
            # Perform any other startup logic.

        def my_custom_function(self):
            # Any additional method in which are you generating a new message using an external source.
            self.send_new({&#34;data&#34;: &#34;New Message Data Here&#34;, &#34;my_custom&#34;: &#34;metadata&#34;})
    ```
    &#39;&#39;&#39;
    msgid = Util.get_id()
    newmsg[&#39;msgid&#39;] = msgid
    if &#34;data&#34; in newmsg:
        newmsg[&#34;fsize&#34;] = len(newmsg[&#34;data&#34;])
    else:
        newmsg[&#34;fsize&#34;] = os.path.getsize(newmsg[&#34;fpath&#34;])
    print(newmsg)
    print(call)
    cast(self.__handler__, (Atom(b&#39;new&#39;), json.dumps(newmsg)))
    return msgid</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="amps" href="index.html">amps</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="amps.service.Service" href="#amps.service.Service">Service</a></code></h4>
<ul class="">
<li><code><a title="amps.service.Service.handle_message" href="#amps.service.Service.handle_message">handle_message</a></code></li>
<li><code><a title="amps.service.Service.initialize" href="#amps.service.Service.initialize">initialize</a></code></li>
<li><code><a title="amps.service.Service.send_message" href="#amps.service.Service.send_message">send_message</a></code></li>
<li><code><a title="amps.service.Service.send_new" href="#amps.service.Service.send_new">send_new</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>